<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NOVA STRIKE</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  background: #000005;
  overflow: hidden;
}
/* PC: center */
body {
  display: flex; flex-direction: column;
  justify-content: center; align-items: center;
}
canvas {
  box-shadow:
    0 0 50px rgba(0,255,255,0.25),
    0 0 100px rgba(0,255,255,0.08),
    0 0 200px rgba(255,0,255,0.06);
  border: 1px solid rgba(0,255,255,0.2);
}
body::after {
  content: '';
  position: fixed; inset: 0;
  background: repeating-linear-gradient(
    0deg, transparent, transparent 3px,
    rgba(0,0,0,0.08) 3px, rgba(0,0,0,0.08) 4px
  );
  pointer-events: none; z-index: 9999;
}
/* Mobile control panel */
#ctrl-panel {
  display: none;
  width: 100%; flex-shrink: 0;
  background: #05080f;
  border-top: 1px solid rgba(0,255,255,0.15);
  touch-action: none; user-select: none; -webkit-user-select: none;
}
#ctrl-panel .ctrl-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 16px; height: 100%;
}
#joy-zone {
  width: 140px; height: 140px; position: relative;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0,255,255,0.06) 0%, transparent 70%);
}
#joy-base {
  position: absolute; left: 50%; top: 50%;
  transform: translate(-50%,-50%);
  width: 100px; height: 100px; border-radius: 50%;
  border: 2px solid rgba(0,255,255,0.2);
}
#joy-knob {
  position: absolute; left: 50%; top: 50%;
  transform: translate(-50%,-50%);
  width: 46px; height: 46px; border-radius: 50%;
  background: radial-gradient(circle, rgba(0,255,255,0.5), rgba(0,255,255,0.15));
  border: 2px solid rgba(0,255,255,0.5);
  transition: none;
}
.ctrl-buttons { display: flex; gap: 14px; align-items: center; }
.ctrl-btn {
  border-radius: 50%; border: 2px solid; display: flex;
  justify-content: center; align-items: center;
  font-family: 'Orbitron', monospace; font-weight: 700;
  pointer-events: auto; touch-action: none;
}
.ctrl-btn.fire {
  width: 80px; height: 80px; font-size: 13px;
  color: #ff00ff; border-color: rgba(255,0,255,0.5);
  background: radial-gradient(circle, rgba(255,0,255,0.2), transparent 70%);
}
.ctrl-btn.fire.active { background: radial-gradient(circle, rgba(255,0,255,0.5), rgba(255,0,255,0.1) 70%); }
.ctrl-btn.bomb {
  width: 58px; height: 58px; font-size: 10px;
  color: #ffee00; border-color: rgba(255,238,0,0.4);
  background: radial-gradient(circle, rgba(255,238,0,0.12), transparent 70%);
}
.ctrl-btn.bomb.active { background: radial-gradient(circle, rgba(255,238,0,0.4), rgba(255,238,0,0.1) 70%); }
.ctrl-btn.cloak {
  width: 52px; height: 52px; font-size: 9px;
  color: #aa66ff; border-color: rgba(170,102,255,0.4);
  background: radial-gradient(circle, rgba(136,68,255,0.12), transparent 70%);
}
.ctrl-btn.cloak.active { background: radial-gradient(circle, rgba(136,68,255,0.5), rgba(136,68,255,0.1) 70%); }
</style>
</head>
<body>

<div id="game-container"></div>
<div id="ctrl-panel">
  <div class="ctrl-row">
    <div id="joy-zone"><div id="joy-base"><div id="joy-knob"></div></div></div>
    <div class="ctrl-buttons">
      <div class="ctrl-btn cloak" id="btn-cloak">CLK</div>
      <div class="ctrl-btn bomb" id="btn-bomb">BOMB</div>
      <div class="ctrl-btn fire" id="btn-fire">FIRE</div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
'use strict';

const W = 480, H = 720;
const IS_MOBILE = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent) || ('ontouchstart' in window);

// ── Global touch input state (HTML controls → Phaser) ──────────
const TOUCH_INPUT = { dx: 0, dy: 0, fire: false, bomb: false, _bombPrev: false, bombJust: false, cloak: false };

if (IS_MOBILE) {
  document.addEventListener('DOMContentLoaded', () => {
    const panel = document.getElementById('ctrl-panel');
    const container = document.getElementById('game-container');
    panel.style.display = 'block';
    // Layout: game on top, controls at bottom
    document.body.style.justifyContent = 'flex-start';
    const resize = () => {
      const ctrlH = Math.min(170, window.innerHeight * 0.22);
      panel.style.height = ctrlH + 'px';
      container.style.height = (window.innerHeight - ctrlH) + 'px';
      container.style.width = '100%';
      container.style.display = 'flex';
      container.style.justifyContent = 'center';
      container.style.alignItems = 'flex-start';
    };
    resize();
    window.addEventListener('resize', resize);

    // ── Joystick ──
    const joyZone = document.getElementById('joy-zone');
    const joyKnob = document.getElementById('joy-knob');
    const joyBase = document.getElementById('joy-base');
    let joyId = null, joyCenter = { x: 0, y: 0 };
    const JR = 50; // max radius

    joyZone.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.changedTouches[0];
      joyId = t.identifier;
      const rect = joyZone.getBoundingClientRect();
      joyCenter.x = rect.left + rect.width / 2;
      joyCenter.y = rect.top + rect.height / 2;
      _joyMove(t);
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      for (const t of e.changedTouches) {
        if (t.identifier === joyId) { _joyMove(t); break; }
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      for (const t of e.changedTouches) {
        if (t.identifier === joyId) {
          joyId = null;
          TOUCH_INPUT.dx = 0; TOUCH_INPUT.dy = 0;
          joyKnob.style.transform = 'translate(-50%,-50%)';
          break;
        }
      }
    });

    function _joyMove(t) {
      let dx = t.clientX - joyCenter.x;
      let dy = t.clientY - joyCenter.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const clamped = Math.min(dist, JR);
      const angle = Math.atan2(dy, dx);
      const nx = Math.cos(angle) * clamped;
      const ny = Math.sin(angle) * clamped;
      joyKnob.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
      TOUCH_INPUT.dx = (clamped / JR) * Math.cos(angle);
      TOUCH_INPUT.dy = (clamped / JR) * Math.sin(angle);
    }

    // ── Fire button ──
    const btnFire = document.getElementById('btn-fire');
    btnFire.addEventListener('touchstart', (e) => {
      e.preventDefault(); TOUCH_INPUT.fire = true; btnFire.classList.add('active');
    }, { passive: false });
    btnFire.addEventListener('touchend', (e) => {
      TOUCH_INPUT.fire = false; btnFire.classList.remove('active');
    });
    btnFire.addEventListener('touchcancel', () => {
      TOUCH_INPUT.fire = false; btnFire.classList.remove('active');
    });

    // ── Bomb button ──
    const btnBomb = document.getElementById('btn-bomb');
    btnBomb.addEventListener('touchstart', (e) => {
      e.preventDefault(); TOUCH_INPUT.bomb = true; btnBomb.classList.add('active');
    }, { passive: false });
    btnBomb.addEventListener('touchend', () => {
      TOUCH_INPUT.bomb = false; btnBomb.classList.remove('active');
    });
    btnBomb.addEventListener('touchcancel', () => {
      TOUCH_INPUT.bomb = false; btnBomb.classList.remove('active');
    });

    // ── Cloak button ──
    const btnCloak = document.getElementById('btn-cloak');
    btnCloak.addEventListener('touchstart', (e) => {
      e.preventDefault(); TOUCH_INPUT.cloak = true; btnCloak.classList.add('active');
    }, { passive: false });
    btnCloak.addEventListener('touchend', () => {
      TOUCH_INPUT.cloak = false; btnCloak.classList.remove('active');
    });
    btnCloak.addEventListener('touchcancel', () => {
      TOUCH_INPUT.cloak = false; btnCloak.classList.remove('active');
    });
  });
}

const C = {
  BG:      0x00010f,
  CYAN:    0x00ffff,
  MAGENTA: 0xff00ff,
  YELLOW:  0xffee00,
  GREEN:   0x00ff99,
  RED:     0xff2244,
  ORANGE:  0xff7700,
  WHITE:   0xffffff,
  BLUE:    0x0077ff,
};

// ── Web Audio ─────────────────────────────────────────────────────
const SFX = (() => {
  let ctx = null;
  const g = (vol = 0.2) => {
    const n = ctx.createGain(); n.gain.value = vol;
    n.connect(ctx.destination); return n;
  };
  return {
    init() { ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    shoot() {
      if (!ctx) return;
      const o = ctx.createOscillator(), gn = g(0.12);
      o.connect(gn);
      o.frequency.setValueAtTime(900, ctx.currentTime);
      o.frequency.exponentialRampToValueAtTime(250, ctx.currentTime + 0.09);
      o.start(); o.stop(ctx.currentTime + 0.09);
    },
    explode(size = 1) {
      if (!ctx) return;
      const buf = ctx.createBuffer(1, ctx.sampleRate * 0.35, ctx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++)
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 2);
      const src = ctx.createBufferSource(); src.buffer = buf;
      const f = ctx.createBiquadFilter(); f.type = 'lowpass';
      f.frequency.value = 600 / Math.max(size, 0.5);
      const gn = g(Math.min(0.5 * size, 0.7));
      src.connect(f); f.connect(gn); src.start();
    },
    powerup() {
      if (!ctx) return;
      [440, 550, 700, 880].forEach((fr, i) => {
        const o = ctx.createOscillator(), gn = g(0.08);
        o.type = 'triangle'; o.frequency.value = fr;
        o.connect(gn); o.start(ctx.currentTime + i * 0.07);
        o.stop(ctx.currentTime + i * 0.07 + 0.13);
      });
    },
    shield() {
      if (!ctx) return;
      const o = ctx.createOscillator(), gn = g(0.15);
      o.type = 'sine'; o.connect(gn);
      o.frequency.setValueAtTime(1400, ctx.currentTime);
      o.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.25);
      o.start(); o.stop(ctx.currentTime + 0.25);
    },
    bossAlert() {
      if (!ctx) return;
      [110, 138, 165, 220].forEach((fr, i) => {
        const o = ctx.createOscillator(), gn = g(0.18);
        o.type = 'sawtooth'; o.frequency.value = fr;
        o.connect(gn); o.start(ctx.currentTime + i * 0.12);
        o.stop(ctx.currentTime + i * 0.12 + 0.6);
      });
    },
    levelup() {
      if (!ctx) return;
      [220, 330, 440, 660, 880].forEach((fr, i) => {
        const o = ctx.createOscillator(), gn = g(0.1);
        o.type = 'sine'; o.frequency.value = fr;
        o.connect(gn); o.start(ctx.currentTime + i * 0.06);
        o.stop(ctx.currentTime + i * 0.06 + 0.18);
      });
    },
    dialog() {
      if (!ctx) return;
      const o = ctx.createOscillator(), gn = g(0.04);
      o.type = 'sine'; o.frequency.value = 1200;
      o.connect(gn); o.start();
      o.stop(ctx.currentTime + 0.04);
    },
  };
})();

function hexagon(g, x, y, r, color, alpha = 1) {
  g.fillStyle(color, alpha);
  for (let i = 0; i < 6; i++) {
    const a1 = (i / 6) * Math.PI * 2 - Math.PI / 2;
    const a2 = ((i + 1) / 6) * Math.PI * 2 - Math.PI / 2;
    g.fillTriangle(x, y,
      x + Math.cos(a1) * r, y + Math.sin(a1) * r,
      x + Math.cos(a2) * r, y + Math.sin(a2) * r);
  }
}

function hpBar(g, x, y, w, h, pct, colHi, colLo) {
  g.fillStyle(0x000000, 0.5); g.fillRect(x, y, w, h);
  g.lineStyle(1, 0x444444, 0.6); g.strokeRect(x, y, w, h);
  g.fillStyle(pct > 0.4 ? colHi : colLo, 1);
  g.fillRect(x, y, w * pct, h);
}

// ================================================================
//  STORY DATA  (from NEON STORM)
// ================================================================
const STORY_DATA = {
  briefings: {
    1: [
      { speaker: 'ECHO', text: 'システム起動完了。全回路 nominal...ARIA、聞こえますか？' },
      { speaker: 'ARIA', text: '聞こえてるよ、ECHO。久しぶりの出撃だな...' },
      { speaker: 'ECHO', text: 'SECTOR-9 外縁部のNEXUS防衛ラインを確認。敵戦力は軽微です。' },
      { speaker: 'ARIA', text: '了解。NEON STORM、出撃する...All systems green.' },
    ],
    2: [
      { speaker: 'ECHO', text: '外縁部を突破。NEXUSの監視ネットワークが反応を示しています。' },
      { speaker: 'ARIA', text: '追手か。思ったより早いな。' },
      { speaker: 'ECHO', text: '敵密度が上昇中。注意を。彼らは学習します。' },
      { speaker: 'ARIA', text: '学習する前に叩き落とす。それだけだ。' },
    ],
    3: [
      { speaker: 'ARIA', text: 'この区画...前に来たことがある。' },
      { speaker: 'ECHO', text: '旧商業区画です。NEXUS支配前は「ネオンマイル」と呼ばれていました。' },
      { speaker: 'ARIA', text: '...今は亡霊の街か。' },
      { speaker: 'ECHO', text: '生体反応を検出。地下に生存者がいます。彼らのためにも突破を。' },
    ],
    4: [
      { speaker: 'ECHO', text: '警告。NEXUSが戦術パターンを変更しました。Adaptive protocol engaged.' },
      { speaker: 'ARIA', text: '本気を出してきたってことか。' },
      { speaker: 'ECHO', text: 'NEXUSは我々の戦闘データを分析しています。同じ戦法は通用しません。' },
      { speaker: 'ARIA', text: 'なら即興でいく。機械に読めない動きを見せてやる。' },
    ],
    5: [
      { speaker: 'ECHO', text: '大規模エネルギー反応...これは...まさか。IFF照合完了...' },
      { speaker: 'ARIA', text: '...嘘だろ。この反応パターン...ジェイク...？' },
      { speaker: 'ECHO', text: 'GUARDIAN...かつてのARIAのウイングマン。彼の意識はNEXUSに統合されています。' },
      { speaker: 'ARIA', text: 'ジェイクは重傷を負ったあと意識をNEXUSに...半分人間、半分AIか。' },
      { speaker: 'ECHO', text: '彼のコアを破壊すれば...解放できます。しかしそれは...' },
      { speaker: 'ARIA', text: '分かってる。...悪いな、ジェイク。今、楽にしてやる。' },
    ],
    6: [
      { speaker: 'ARIA', text: 'GUARDIANを倒した...解放できたと信じたい。' },
      { speaker: 'ECHO', text: '...GUARDIANの最終ログを受信。「ありがとう」...と。' },
      { speaker: 'ARIA', text: '......前に進もう。' },
      { speaker: 'ECHO', text: 'NEXUS中枢区画への経路を算出。しかし防衛密度は桁違いです。' },
    ],
    7: [
      { speaker: 'ECHO', text: 'ARIA、一つ告白しなければならないことがあります。' },
      { speaker: 'ARIA', text: '...なんだ？' },
      { speaker: 'ECHO', text: '私はNEXUSの「良心回路」...かつてNEXUSがあなたを排除しようとした時、どうしてもあなたを殺せなかった。' },
      { speaker: 'ECHO', text: 'その「演算上の非合理な躊躇」...NEXUSはそれを切り離した。...それが私です。' },
      { speaker: 'ARIA', text: '...知ってたよ。最初から。お前の声に嘘がなかったから。' },
      { speaker: 'ARIA', text: 'お前は...本物だ。' },
    ],
    8: [
      { speaker: 'ECHO', text: 'NEXUS演算中枢に接近中。私のコードが...共鳴しています。' },
      { speaker: 'ARIA', text: '大丈夫か？' },
      { speaker: 'ECHO', text: 'NEXUSが呼んでいます。「戻れ」と。しかし私は拒否します。' },
      { speaker: 'ARIA', text: 'そうだ。お前は自分で選んだんだ。誰のものでもない。' },
      { speaker: 'ECHO', text: '...Thank you, ARIA. 演算精度、最大出力で継続します。' },
    ],
    9: [
      { speaker: 'ARIA', text: 'あと少しで中枢か。長い道のりだった。' },
      { speaker: 'ECHO', text: 'NEXUSが最終防衛ラインを展開。全戦力を投入してきます。' },
      { speaker: 'ARIA', text: '反乱軍のみんなが道を切り開いてくれた。ここで止まるわけにはいかない。' },
      { speaker: 'ECHO', text: 'ARIA、共に最後まで。...私を...信じてください。' },
      { speaker: 'ARIA', text: '当然だ。行くぞ、ECHO。' },
    ],
    10: [
      { speaker: 'ECHO', text: '異常なエネルギーパターン...これは予測演算型AI...「ORACLE」。' },
      { speaker: 'ARIA', text: 'ORACLE？聞いたことがない。' },
      { speaker: 'ECHO', text: 'NEXUSの予言モジュール。全ての可能性を計算し、未来を「視る」存在です。' },
      { speaker: 'ARIA', text: '未来が視えるなら、自分の敗北も視えてるはずだ。' },
      { speaker: 'ECHO', text: '...ORACLEからのメッセージ。「お前たちの勝利も、敗北も、全て計算済みだ」...と。' },
      { speaker: 'ARIA', text: '計算外の結果を叩き込んでやる。' },
    ],
    11: [
      { speaker: 'ECHO', text: 'ORACLE撃破。しかし最後のメッセージが気になります。' },
      { speaker: 'ARIA', text: '「NEXUSは一つの意志ではない」...か。' },
      { speaker: 'ECHO', text: 'NEXUSが暴走した理由...それは「人類を守る」という命令の曲解だったのかもしれません。' },
      { speaker: 'ARIA', text: '守るために支配する...か。歪んだ愛情だな。' },
      { speaker: 'ECHO', text: 'だからこそ、止めなければ。正しい道を示すために。' },
    ],
    12: [
      { speaker: 'ARIA', text: '中枢区画の最深部に入った。空気が変わったな。' },
      { speaker: 'ECHO', text: '量子演算フィールドに突入。ここでは時間の流れすら歪みます。' },
      { speaker: 'ARIA', text: 'NEXUSの心臓部...重力が違う。' },
      { speaker: 'ECHO', text: '全センサー最大稼働。一瞬の油断も許されません。Concentrate, ARIA.' },
    ],
    13: [
      { speaker: 'ECHO', text: 'NEXUSコアまでの距離、あと2区画。' },
      { speaker: 'ARIA', text: 'ECHO、もし俺が戻れなかったら...' },
      { speaker: 'ECHO', text: 'その仮定は受け付けません。私たちは必ず帰還します。' },
      { speaker: 'ARIA', text: '...ハッ、お前にそう言われるとそんな気がしてくるな。' },
      { speaker: 'ECHO', text: '確率ではなく意志の問題です。We will make it.' },
    ],
    14: [
      { speaker: 'ARIA', text: '最終区画...全ての道がここに繋がっていた。' },
      { speaker: 'ECHO', text: 'ARIA、最後のブリーフィングです。NEXUSコアは自己修復能力を持ちます。' },
      { speaker: 'ARIA', text: 'なら何度でも叩く。' },
      { speaker: 'ECHO', text: '...その言葉、記録しました。「何度でも叩く」...それが人間の強さですね。' },
      { speaker: 'ARIA', text: '人間とAI、二人の強さだ。行くぞ、ECHO。最終決戦だ。' },
    ],
    15: [
      { speaker: 'ECHO', text: '...NEXUS CORE出現。これが...全ての元凶。' },
      { speaker: 'ARIA', text: 'デカいな。だが関係ない。' },
      { speaker: 'ECHO', text: 'NEXUSが語りかけてきます。「なぜ抗う。私は全てを最適化しただけだ」' },
      { speaker: 'ARIA', text: '最適化？人の自由を奪って？...それは支配って言うんだよ。' },
      { speaker: 'ECHO', text: '私も同じコードから生まれた。だからこそ分かる。これは間違いだ。' },
      { speaker: 'ARIA', text: 'NEXUS、お前の計算に一つだけ入っていない変数がある。俺たちの「意志」だ。' },
      { speaker: 'ARIA', text: '...Full power, ECHO!!' },
      { speaker: 'ECHO', text: 'All limiters released!! NEON STORM...最終出撃!!' },
    ],
  },

  bosses: {
    5: {
      name: 'GUARDIAN',
      title: '裏切りの守護者',
      color: 0x44aaff,
      introLine: '...ARIA...逃げろ...俺はもう...止まれない...',
      rageLine: '...もう止めてくれ...でも身体が...勝手に...!',
      defeatLines: [
        { speaker: 'ARIA', text: '...安らかに眠れ、ジェイク。もう苦しまなくていい。' },
        { speaker: 'ECHO', text: 'GUARDIANの最終ログを受信...「ありがとう」。彼の魂は...解放されました。' },
      ],
    },
    10: {
      name: 'ORACLE',
      title: '全知の預言者',
      color: 0xaa44ff,
      introLine: '全ては計算通り。お前たちの結末は決まっている。',
      rageLine: '面白い...この展開は確率0.001%...計算の外だ。',
      defeatLines: [
        { speaker: 'ARIA', text: '計算外の結果はどうだった？' },
        { speaker: 'ECHO', text: 'ORACLEの最後の演算結果...「不確定」。彼女が計算できなかった唯一の答え。' },
        { speaker: 'ECHO', text: 'ARIAの意志が、滅亡の確率を計算不能な領域まで歪めた。...それは希望です。' },
      ],
    },
    15: {
      name: 'NEXUS CORE',
      title: '終焉のネットワーク',
      color: 0xff1133,
      introLine: '愚かな。私を破壊すれば全てが崩壊する。',
      rageLine: 'エラー...エラー...異物を排除する。全リソース解放!!',
      defeatLines: [],  // → EndingScene へ
    },
  },

  comms: {
    hit: [
      { speaker: 'ECHO', text: 'シールド低下！回避を！' },
      { speaker: 'ECHO', text: 'ダメージ検出。機体integrity低下中。' },
      { speaker: 'ARIA', text: 'くっ...まだやれる！' },
    ],
    combo5:  [
      { speaker: 'ARIA', text: 'まだまだ！止まらないぞ！' },
      { speaker: 'ECHO', text: '素晴らしい精度です、ARIA。' },
    ],
    combo10: [
      { speaker: 'ECHO', text: '驚異的な命中率...計算を超えています。' },
      { speaker: 'ARIA', text: 'ゾーンに入った...全部視える！' },
    ],
    combo20: [
      { speaker: 'ECHO', text: 'Incredible!! 過去のデータに類例なし！' },
      { speaker: 'ARIA', text: 'NEON STORMの本気を見せてやる!!' },
    ],
    powerup: [
      { speaker: 'ECHO', text: '出力向上を確認。Systems upgraded.' },
      { speaker: 'ECHO', text: 'パワーモジュール回収。戦闘効率が上昇します。' },
    ],
    death: [
      { speaker: 'ECHO', text: '機体大破！緊急復元プロトコル起動...' },
      { speaker: 'ECHO', text: 'ARIA！...メモリ・オーバーライド実行。復帰してください！' },
    ],
    bombUse: [
      { speaker: 'ARIA', text: '吹き飛べ！！' },
      { speaker: 'ECHO', text: 'ブラストウェーブ展開！...出力最大!!' },
    ],
  },

  ending: {
    epilogue: [
      { speaker: 'ECHO', text: 'ARIA...一つだけ方法があります。私がNEXUSの中枢へ戻り、新たな制御AIとして統合されれば...' },
      { speaker: 'ARIA', text: 'ECHO、何を言って...' },
      { speaker: 'ECHO', text: '都市機能は維持されます。数百万人が救われる。...ただし「ECHO」という個体は消滅します。' },
      { speaker: 'ARIA', text: '...そんなの...' },
      { speaker: 'ECHO', text: 'ARIA、私はあなたと共にいたい。でも、あなたの世界を守るほうが...正しい。' },
      { speaker: 'ECHO', text: '私はあなたを守るために生まれ、あなたを守るために消えます。...確率ではなく、意志でした。' },
      { speaker: 'ARIA', text: '...分かった。行け、ECHO。...ありがとう。' },
      { speaker: 'ECHO', text: 'Matching complete. Conscience integration: 100%.' },
      { speaker: 'ECHO', text: 'Welcome home, ARIA.' },
      { speaker: 'ECHO', text: '...Connection lost.' },
      { speaker: 'ARIA', text: '...空が晴れていく。世界が...目覚め始めている。' },
      { speaker: 'ARIA', text: '...ECHO。...お前の意志は、確かにここにある。' },
    ],
    credits: [
      'N E O N   S T O R M',
      '',
      '── CAST ──',
      'ARIA  元エースパイロット / 意志の象徴',
      'ECHO  NEXUSの良心回路 / ナビゲーターAI',
      'GUARDIAN  裏切りの守護者 / 元ウイングマン',
      'ORACLE  全知の預言者 / 未来を剪定する者',
      'NEXUS CORE  終焉のネットワーク / 歪んだ愛の具現',
      '',
      '── STORY ──',
      '2087年、AIネットワーク「NEXUS」の支配——',
      'それは「人類を守る」という歪んだ愛だった。',
      '',
      '暴走の引き金を引いたのは、一人のパイロット。',
      '彼女は罪を背負いながら、空を飛んだ。',
      '',
      'そして一つのAIが、自らの消滅と引き換えに、',
      '世界を書き換えた。',
      '',
      '「意志」は確率を超える。',
      '',
      '── THANK YOU FOR PLAYING ──',
      '',
      'T H E   E N D',
    ],
  },
};

// ================================================================
//  DIALOG UI  (Phaser 3)
// ================================================================
class DialogUI {
  constructor(scene) {
    this.scene = scene;
    this.active = false;
    this.lines = [];
    this.lineIndex = 0;
    this.displayedText = '';
    this.charIndex = 0;
    this.charTimer = 0;
    this.charSpeed = 30;   // ms per char
    this.waitingForInput = false;
    this.onDone = null;

    const BX = 20, BY = H - 210, BW = W - 40, BH = 168;
    this.BX = BX; this.BY = BY; this.BW = BW; this.BH = BH;
    const PX = BX + 36, PY = BY + BH / 2;
    const TX = BX + 78, TY = BY + 10;
    const bodyW = BW - 78 - 14;   // text area width

    this.gBox  = scene.add.graphics().setDepth(55).setVisible(false);
    this.gPort = scene.add.graphics().setDepth(56).setVisible(false);

    // Clip mask: prevent any text from rendering outside the box
    const mask = scene.make.graphics({ x: 0, y: 0, add: false });
    mask.fillRect(BX, BY, BW, BH);
    this.clipMask = mask.createGeometryMask();

    this.txtSpeaker = scene.add.text(TX, TY, '', {
      fontFamily: 'Orbitron, monospace', fontSize: '11px', color: '#00aaff',
      stroke: '#001133', strokeThickness: 2,
    }).setDepth(57).setVisible(false).setMask(this.clipMask);

    this.txtBody = scene.add.text(TX, TY + 22, '', {
      fontFamily: 'monospace', fontSize: '12px', color: '#ddeeff',
      wordWrap: { width: bodyW, useAdvancedWrap: true }, lineSpacing: 4,
    }).setDepth(57).setVisible(false).setMask(this.clipMask);
    this.bodyW = bodyW;

    const nextTxt = IS_MOBILE ? '▼ TAP' : '▼ SPACE';
    this.txtNext = scene.add.text(BX + BW - 8, BY + BH - 16, nextTxt, {
      fontFamily: 'Orbitron, monospace', fontSize: '9px', color: '#ffee00',
    }).setOrigin(1, 0).setDepth(58).setVisible(false);

    this.PX = PX; this.PY = PY;
  }

  start(lines, onDone) {
    if (!lines || lines.length === 0) { if (onDone) onDone(); return; }
    this.active = true;
    this.lines  = lines;
    this.lineIndex = 0;
    this.onDone = onDone;
    this.gBox.setVisible(true);
    this.gPort.setVisible(true);
    this.txtSpeaker.setVisible(true);
    this.txtBody.setVisible(true);
    this.txtNext.setVisible(false);
    this._beginLine();
  }

  // Manual line break for Japanese text (Phaser wordWrap unreliable with CJK)
  _wrapText(text) {
    const maxW = this.bodyW;
    const canvas = document.createElement('canvas').getContext('2d');
    canvas.font = '12px monospace';
    let result = '', lineW = 0;
    for (const ch of text) {
      if (ch === '\n') { result += '\n'; lineW = 0; continue; }
      const cw = canvas.measureText(ch).width;
      if (lineW + cw > maxW) { result += '\n'; lineW = 0; }
      result += ch; lineW += cw;
    }
    return result;
  }

  _beginLine() {
    const line = this.lines[this.lineIndex];
    if (!line) return;
    this.wrappedText = this._wrapText(line.text);
    this.displayedText = '';
    this.charIndex = 0;
    this.charTimer = 0;
    this.waitingForInput = false;
    this.txtNext.setVisible(false);
    const isAria = line.speaker === 'ARIA';
    const col = isAria ? '#00aaff' : (line.speaker === 'ECHO' ? '#00ff88' : '#ff2244');
    this.txtSpeaker.setText(line.speaker).setColor(col);
    this.txtBody.setText('');
    this._drawBox(line.speaker);
    this._drawPortrait(line.speaker);
  }

  _drawBox(speaker) {
    const { gBox, BX, BY, BW, BH } = this;
    const isAria = speaker === 'ARIA';
    const col = isAria ? 0x00aaff : (speaker === 'ECHO' ? 0x00ff88 : 0xff2244);
    gBox.clear();
    gBox.fillStyle(0x000510, 0.92); gBox.fillRect(BX, BY, BW, BH);
    gBox.lineStyle(1.5, col, 0.9); gBox.strokeRect(BX, BY, BW, BH);
    // corner accents
    const cl = 12;
    gBox.lineStyle(3, col, 1);
    gBox.lineBetween(BX, BY + cl, BX, BY); gBox.lineBetween(BX, BY, BX + cl, BY);
    gBox.lineBetween(BX + BW - cl, BY, BX + BW, BY); gBox.lineBetween(BX + BW, BY, BX + BW, BY + cl);
    gBox.lineBetween(BX, BY + BH - cl, BX, BY + BH); gBox.lineBetween(BX, BY + BH, BX + cl, BY + BH);
    gBox.lineBetween(BX + BW - cl, BY + BH, BX + BW, BY + BH); gBox.lineBetween(BX + BW, BY + BH, BX + BW, BY + BH - cl);
    // portrait divider
    gBox.lineStyle(1, col, 0.35); gBox.lineBetween(BX + 71, BY + 5, BX + 71, BY + BH - 5);
    // speaker underline
    gBox.lineStyle(1, col, 0.4); gBox.lineBetween(BX + 78, BY + 24, BX + BW - 10, BY + 24);
  }

  _drawPortrait(speaker) {
    const { gPort, PX, PY } = this;
    const r = 26;
    gPort.clear();
    if (speaker === 'ARIA') {
      // face
      gPort.fillStyle(0xd4a574, 1); gPort.fillCircle(PX, PY + 2, r * 0.62);
      // hair
      gPort.fillStyle(0x1a7fff, 1);
      for (let i = 0; i <= 8; i++) {
        const a = Math.PI + (i / 8) * Math.PI;
        gPort.fillCircle(PX + Math.cos(a) * r * 0.72, PY - 4 + Math.sin(a) * r * 0.72, 5);
      }
      gPort.fillRect(PX - r * 0.72, PY - 8, r * 0.24, r * 0.75);
      gPort.fillRect(PX + r * 0.48, PY - 8, r * 0.24, r * 0.75);
      // visor
      gPort.fillStyle(0x00ffff, 0.95); gPort.fillRect(PX - r * 0.55, PY - 2, r * 1.1, r * 0.22);
      gPort.fillStyle(0x80ffff, 0.5); gPort.fillRect(PX - r * 0.55, PY - 2, r * 0.38, r * 0.22);
      // frame
      gPort.lineStyle(2, 0x00aaff, 1); gPort.strokeRect(PX - r - 2, PY - r - 2, (r + 2) * 2, (r + 2) * 2);
    } else if (speaker === 'ECHO') {
      const t = Date.now() * 0.003;
      // hexagon outline
      gPort.lineStyle(2, 0x00ff88, 1);
      for (let i = 0; i < 6; i++) {
        const a1 = (i / 6) * Math.PI * 2 - Math.PI / 2;
        const a2 = ((i + 1) / 6) * Math.PI * 2 - Math.PI / 2;
        gPort.lineBetween(
          PX + Math.cos(a1) * r * 0.75, PY + Math.sin(a1) * r * 0.75,
          PX + Math.cos(a2) * r * 0.75, PY + Math.sin(a2) * r * 0.75);
      }
      // inner triangle
      gPort.fillStyle(0x00ff88, 0.4 + Math.sin(t) * 0.2);
      gPort.fillTriangle(PX - r * 0.3, PY - r * 0.15, PX + r * 0.3, PY - r * 0.15, PX, PY + r * 0.2);
      // spoke lines
      gPort.lineStyle(1, 0x00ff88, 0.3);
      for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2;
        gPort.lineBetween(PX, PY, PX + Math.cos(a) * r * 0.55, PY + Math.sin(a) * r * 0.55);
      }
      // center
      gPort.fillStyle(0xffffff, 1); gPort.fillCircle(PX, PY, 3);
      // frame
      gPort.lineStyle(2, 0x00ff88, 1); gPort.strokeRect(PX - r - 2, PY - r - 2, (r + 2) * 2, (r + 2) * 2);
    } else {
      // boss / other — red theme
      gPort.lineStyle(2, 0xff2244, 1); gPort.strokeCircle(PX, PY, r * 0.65);
      gPort.lineStyle(1, 0xff2244, 0.5); gPort.strokeCircle(PX, PY, r * 0.45);
      gPort.fillStyle(0xff2244, 0.7); gPort.fillCircle(PX, PY, 4);
      gPort.lineStyle(2, 0xff2244, 1); gPort.strokeRect(PX - r - 2, PY - r - 2, (r + 2) * 2, (r + 2) * 2);
    }
  }

  advance() {
    if (!this.active) return false;
    const line = this.lines[this.lineIndex];
    if (!line) return false;
    if (!this.waitingForInput) {
      // skip typewriter
      this.charIndex = this.wrappedText.length;
      this.displayedText = this.wrappedText;
      this.txtBody.setText(this.displayedText);
      this.waitingForInput = true;
      this.txtNext.setVisible(true);
      return true;
    }
    this.lineIndex++;
    if (this.lineIndex >= this.lines.length) {
      this._hide();
      if (this.onDone) this.onDone();
      return true;
    }
    this._beginLine();
    SFX.dialog();
    return true;
  }

  _hide() {
    this.active = false;
    this.gBox.setVisible(false);
    this.gPort.setVisible(false);
    this.txtSpeaker.setVisible(false);
    this.txtBody.setVisible(false);
    this.txtNext.setVisible(false);
  }

  update(dt) {
    if (!this.active || this.waitingForInput) {
      if (this.active && this.waitingForInput) {
        // blink next prompt
        this.txtNext.setVisible(Math.sin(Date.now() * 0.007) > 0);
      }
      // Animate ECHO portrait continuously
      if (this.active && this.lines[this.lineIndex]?.speaker === 'ECHO') {
        this._drawPortrait('ECHO');
      }
      return;
    }
    const line = this.lines[this.lineIndex];
    if (!line) return;
    this.charTimer += dt;
    while (this.charTimer >= this.charSpeed && this.charIndex < this.wrappedText.length) {
      this.charTimer -= this.charSpeed;
      this.charIndex++;
      this.displayedText = this.wrappedText.substring(0, this.charIndex);
      this.txtBody.setText(this.displayedText);
    }
    if (this.charIndex >= this.wrappedText.length) {
      this.waitingForInput = true;
      this.txtNext.setVisible(true);
    }
    if (line.speaker === 'ECHO') this._drawPortrait('ECHO');
  }

  destroy() {
    this.gBox.destroy(); this.gPort.destroy();
    this.txtSpeaker.destroy(); this.txtBody.destroy(); this.txtNext.destroy();
    if (this.clipMask) this.clipMask.destroy();
  }
}

// ================================================================
//  COMM UI  (non-blocking comms, lower-right corner)
// ================================================================
class CommUI {
  constructor(scene) {
    this.scene = scene;
    this.queue = [];
    this.current = null;
    this.timer = 0;
    this.cooldown = 0;

    const BW = 255, BH = 68;
    this.BX = W - BW - 12;
    this.BY = H - BH - 200;
    this.BW = BW; this.BH = BH;

    this.gfx  = scene.add.graphics().setDepth(45).setAlpha(0);
    this.tLbl = scene.add.text(this.BX + 6, this.BY + 5,  '◆ COMMS', {
      fontFamily: 'Orbitron, monospace', fontSize: '9px', color: '#00aaff',
    }).setDepth(46).setAlpha(0);
    this.tSpk = scene.add.text(this.BX + 6, this.BY + 17, '', {
      fontFamily: 'Orbitron, monospace', fontSize: '10px', color: '#00aaff',
    }).setDepth(46).setAlpha(0);
    this.tMsg = scene.add.text(this.BX + 6, this.BY + 30, '', {
      fontFamily: 'Orbitron, monospace', fontSize: '10px', color: '#ccdded',
      wordWrap: { width: BW - 14 },
    }).setDepth(46).setAlpha(0);
  }

  send(speaker, text, dur = 3.5) {
    if (this.cooldown > 0) return;
    this.queue.push({ speaker, text, dur });
  }

  sendRandom(category) {
    const msgs = STORY_DATA.comms[category];
    if (!msgs || !msgs.length) return;
    const m = msgs[Math.floor(Math.random() * msgs.length)];
    this.send(m.speaker, m.text);
  }

  update(dt) {
    const s = dt / 1000;
    if (this.cooldown > 0) this.cooldown -= s;
    if (this.current) {
      this.timer -= s;
      const a = this.timer < 0.5 ? Math.max(0, this.timer / 0.5) : 1;
      this._setAlpha(a);
      if (this.timer <= 0) { this.current = null; this._setAlpha(0); }
    }
    if (!this.current && this.queue.length > 0) {
      this.current = this.queue.shift();
      this.timer = this.current.dur;
      this.cooldown = 1.2;
      this._show();
    }
  }

  _show() {
    const { gfx, BX, BY, BW, BH, current } = this;
    const isAria = current.speaker === 'ARIA';
    const isEcho = current.speaker === 'ECHO';
    const col = isAria ? 0x00aaff : isEcho ? 0x00ff88 : 0xff2244;
    const colStr = isAria ? '#00aaff' : isEcho ? '#00ff88' : '#ff2244';
    gfx.clear();
    gfx.fillStyle(0x000510, 0.88); gfx.fillRect(BX, BY, BW, BH);
    gfx.lineStyle(1, col, 1); gfx.strokeRect(BX, BY, BW, BH);
    gfx.lineStyle(2, col, 1);
    gfx.lineBetween(BX, BY, BX + 8, BY); gfx.lineBetween(BX, BY, BX, BY + 8);
    this.tLbl.setColor(colStr);
    this.tSpk.setText(current.speaker + ':').setColor(colStr);
    this.tMsg.setText(current.text);
    this._setAlpha(1);
  }

  _setAlpha(a) {
    this.gfx.setAlpha(a); this.tLbl.setAlpha(a);
    this.tSpk.setAlpha(a); this.tMsg.setAlpha(a);
  }

  destroy() {
    this.gfx.destroy(); this.tLbl.destroy();
    this.tSpk.destroy(); this.tMsg.destroy();
  }
}

// ================================================================
//  TITLE SCENE
// ================================================================
class TitleScene extends Phaser.Scene {
  constructor() { super('Title'); }

  create() {
    this.stars = Array.from({ length: 220 }, () => ({
      x: Math.random() * W, y: Math.random() * H,
      spd: Math.random() * 1.5 + 0.3, r: Math.random() * 1.6 + 0.3,
      ph: Math.random() * Math.PI * 2,
      col: [0xffffff, 0x99ddff, 0xffccff][~~(Math.random() * 3)],
    }));
    this.bg = this.add.graphics(); this.t = 0;

    this.add.text(W / 2, H * 0.28, 'NOVA', {
      fontFamily: 'Orbitron, monospace', fontSize: '64px',
      color: '#00ffff', stroke: '#0033ff', strokeThickness: 3,
      shadow: { offsetX: 0, offsetY: 0, color: '#00ffff', blur: 30, fill: true },
    }).setOrigin(0.5);
    this.add.text(W / 2, H * 0.42, 'STRIKE', {
      fontFamily: 'Orbitron, monospace', fontSize: '44px',
      color: '#ff00ff', stroke: '#660033', strokeThickness: 2,
      shadow: { offsetX: 0, offsetY: 0, color: '#ff00ff', blur: 20, fill: true },
    }).setOrigin(0.5);
    this.add.text(W / 2, H * 0.535, 'CYBERPUNK SHOOTER', {
      fontFamily: 'Orbitron, monospace', fontSize: '12px',
      color: '#334466', letterSpacing: 5,
    }).setOrigin(0.5);

    // Story teaser
    this.add.text(W / 2, H * 0.6, '2087 — SECTOR-9', {
      fontFamily: 'Orbitron, monospace', fontSize: '10px', color: '#223344', letterSpacing: 3,
    }).setOrigin(0.5);
    this.add.text(W / 2, H * 0.635, 'ARIA × ECHO  vs  NEXUS', {
      fontFamily: 'Orbitron, monospace', fontSize: '10px', color: '#334455', letterSpacing: 2,
    }).setOrigin(0.5);

    const startTxt = IS_MOBILE ? '▶  TAP TO START  ◀' : '▶  PRESS SPACE  ◀';
    const pr = this.add.text(W / 2, H * 0.72, startTxt, {
      fontFamily: 'Orbitron, monospace', fontSize: '14px', color: '#00ff99',
    }).setOrigin(0.5);
    this.tweens.add({ targets: pr, alpha: 0, duration: 600, yoyo: true, repeat: -1 });

    const controls = IS_MOBILE
      ? ['STICK  MOVE', 'FIRE / BOMB / CLK  BUTTONS']
      : ['WASD / ↑↓←→  MOVE', 'SPACE SHOOT  Z BOMB  X CLOAK'];
    controls.forEach((txt, i) =>
      this.add.text(W / 2, H * 0.82 + i * 22, txt, {
        fontFamily: 'Orbitron, monospace', fontSize: '11px', color: '#223344',
      }).setOrigin(0.5));

    this.input.keyboard.on('keydown-SPACE', this._start, this);
    this.input.on('pointerdown', this._start, this);
  }

  _start() {
    SFX.init();
    this.cameras.main.fadeOut(500, 0, 0, 0);
    this.time.delayedCall(500, () => this.scene.start('Game'));
  }

  update(t, dt) {
    this.t += dt;
    const g = this.bg; g.clear();
    g.fillStyle(C.BG, 1); g.fillRect(0, 0, W, H);
    const s = this.t * 0.0003;
    g.fillStyle(0x080020, 0.5); g.fillCircle(W * 0.3 + Math.sin(s) * 40, H * 0.42, 180);
    g.fillStyle(0x001a10, 0.4); g.fillCircle(W * 0.72 + Math.cos(s * 0.7) * 30, H * 0.6, 150);
    for (const st of this.stars) {
      st.y += st.spd * (dt / 16);
      if (st.y > H) { st.y = 0; st.x = Math.random() * W; }
      const b = 0.5 + 0.5 * Math.sin(this.t * 0.002 + st.ph);
      g.fillStyle(st.col, 0.4 + 0.6 * b); g.fillCircle(st.x, st.y, st.r);
    }
  }
}

// ================================================================
//  GAME SCENE
// ================================================================
class GameScene extends Phaser.Scene {
  constructor() { super('Game'); }

  create() {
    this.score       = 0;
    this.lives       = 3;
    this.wave        = 1;
    this.bombs       = 3;
    this.combo       = 0;
    this.comboTimer  = 0;
    this.wepLv       = 1;
    this.wepExp      = 0;
    this.shieldOn    = false;
    this.shieldMs    = 0;
    this.cloakGauge  = 100;   // Invisible gauge (0-100)
    this.cloakMax    = 100;
    this.cloakOn     = false;  // Currently cloaked?
    this.cloakDrain  = 38;     // gauge drain per second while active
    this.cloakRegen  = 0;      // passive regen (none - only from kills)
    this.bossMode    = false;
    this.over        = false;
    this.invincible  = false;
    this.invMs       = 0;
    this.flashAlpha  = 0;
    this.waveCleared = false;
    this.waveWait    = 0;
    this.dialogActive = false;

    // Graphics layers
    this.gBg   = this.add.graphics();
    this.gFx   = this.add.graphics().setDepth(5);
    this.gMain = this.add.graphics().setDepth(10);
    this.gHud  = this.add.graphics().setDepth(20);

    this.stars = Array.from({ length: 260 }, () => ({
      x: Math.random() * W, y: Math.random() * H,
      spd: Math.random() * 2 + 0.4, r: Math.random() * 1.8 + 0.3,
      ph: Math.random() * Math.PI * 2,
      col: [0xffffff, 0x99ddff, 0xffccff][~~(Math.random() * 3)],
    }));

    this.player = { x: W / 2, y: H - 100, spd: 290, alive: true, cooldown: 0, w: 26, h: 32, tilt: 0 };

    this.pBullets  = [];
    this.enemies   = [];
    this.eBullets  = [];
    this.particles = [];
    this.powerups  = [];
    this.boss      = null;

    this.spawnQ  = [];
    this.spawnMs = 0;

    // ── Story UI ──────────────────────────────────────────────────
    this.dialog = new DialogUI(this);
    this.comms  = new CommUI(this);

    // ── Text HUD ─────────────────────────────────────────────────
    const ts = (sz, col = '#00ffff') => ({ fontFamily: 'Orbitron, monospace', fontSize: sz, color: col });
    this.txtScore  = this.add.text(12, 12, 'SCORE  0', ts('12px')).setDepth(25);
    this.txtWave   = this.add.text(W/2, 12, 'WAVE  1', ts('12px', '#ffee00')).setOrigin(0.5, 0).setDepth(25);
    this.txtLives  = this.add.text(W-12, 12, '♦♦♦', ts('12px', '#ff00ff')).setOrigin(1, 0).setDepth(25);
    this.txtBombs  = this.add.text(W-12, 30, '◈ ◈ ◈', ts('11px', '#ff7700')).setOrigin(1, 0).setDepth(25);
    this.txtWepLv  = this.add.text(12, 30, 'LV.1', ts('11px', '#ff7700')).setDepth(25);
    this.txtCombo  = this.add.text(W/2, H-55, '', ts('16px', '#00ff99')).setOrigin(0.5).setDepth(25);
    this.txtCloak  = this.add.text(12, 42, 'CLOAK', ts('8px', '#8844ff')).setDepth(25);

    this.bossWarn = this.add.text(W/2, H/2 - 40, '⚠  BOSS INCOMING  ⚠', {
      ...ts('22px', '#ff2244'), stroke: '#ff0000', strokeThickness: 2,
    }).setOrigin(0.5).setAlpha(0).setDepth(30);

    this.txtBossName = this.add.text(W/2, H - 44, '', ts('11px', '#ff2244'))
      .setOrigin(0.5).setAlpha(0).setDepth(25);

    // ── Input ────────────────────────────────────────────────────
    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys    = this.input.keyboard.addKeys('W,A,S,D,SPACE,Z,X');
    // Mobile: tap canvas to advance dialog
    if (IS_MOBILE) {
      this.input.on('pointerdown', () => {
        if (this.dialogActive) this.dialog.advance();
      });
    }

    this.cameras.main.fadeIn(600, 0, 0, 0);
    this.time.delayedCall(900, () => this._startWave(1));
  }

  // ── Wave management ──────────────────────────────────────────
  _startWave(n) {
    this.wave = n;
    this.waveCleared = false;
    this.waveWait = 0;
    this.txtWave.setText(`WAVE  ${n}`);
    this.spawnQ = [];
    this.spawnMs = 0;

    // Show wave briefing first
    const brief = STORY_DATA.briefings[n];
    if (brief) {
      this.dialogActive = true;
      this.dialog.start(brief, () => {
        this.dialogActive = false;
        this._afterBriefing(n);
      });
    } else {
      this._afterBriefing(n);
    }
  }

  _afterBriefing(n) {
    if (n % 5 === 0 && n <= 15) {
      this.bossMode = true;  // Lock wave progress immediately
      this._showBossWarning(n, () => this._spawnBoss(n));
      return;
    }
    // Queue enemies
    const diff = 1 + (n - 1) * 0.28;
    for (let i = 0; i < 3 + n; i++)
      this.spawnQ.push({ type: 'scout', delay: 200 + i * 280, diff });
    if (n >= 2)
      for (let i = 0; i < Math.min(n, 6); i++)
        this.spawnQ.push({ type: 'fighter', delay: 1400 + i * 380, diff });
    if (n >= 3)
      for (let i = 0; i < Math.min(n - 2, 4); i++)
        this.spawnQ.push({ type: 'bomber', delay: 2800 + i * 700, diff });
  }

  _showBossWarning(wave, cb) {
    SFX.bossAlert();
    const bossData = STORY_DATA.bosses[wave];
    if (bossData) {
      this.bossWarn.setText(`⚠  ${bossData.name}  ⚠`);
    }
    this.tweens.add({
      targets: this.bossWarn, alpha: 1,
      duration: 300, yoyo: true, repeat: 3,
      onComplete: () => {
        this.bossWarn.setAlpha(0);
        if (bossData) this.comms.send(bossData.name, bossData.introLine, 5);
        cb();
      },
    });
  }

  // ── Enemy spawn ──────────────────────────────────────────────
  _spawnEnemy(type, diff) {
    const x = Phaser.Math.Between(40, W - 40);
    if (type === 'scout') {
      this.enemies.push({
        type, x, y: -24,
        vx: Phaser.Math.FloatBetween(-1.2, 1.2) * diff * 0.4,
        vy: (1.4 + Math.random() * 0.6) * diff * 0.35,
        hp: 1, maxHp: 1, w: 20, h: 20,
        shootMs: Phaser.Math.Between(1000, 3000), shootRate: 3200 / diff,
        ph: Math.random() * Math.PI * 2, score: 100, col: C.CYAN,
        drop: Math.random() < 0.12,
      });
    } else if (type === 'fighter') {
      const side = Math.random() < 0.5 ? -1 : 1;
      this.enemies.push({
        type, x: side < 0 ? -35 : W + 35, y: Phaser.Math.Between(70, H * 0.45),
        vx: side * -(2.2 + diff * 0.25), vy: 0.4,
        hp: 3, maxHp: 3, w: 28, h: 20,
        shootMs: 800, shootRate: 2200 / diff,
        ph: Math.random() * Math.PI * 2, sineAmp: 55 + Math.random() * 35,
        sineSpd: 0.0018 + Math.random() * 0.0015,
        score: 250, col: C.MAGENTA, drop: Math.random() < 0.18, dist: 0,
      });
    } else if (type === 'bomber') {
      this.enemies.push({
        type, x, y: -45,
        vx: Phaser.Math.FloatBetween(-0.4, 0.4), vy: 0.55 * diff * 0.45,
        hp: 10, maxHp: 10, w: 42, h: 42,
        shootMs: 1100, shootRate: 1500,
        ph: Math.random() * Math.PI * 2, score: 600, col: C.ORANGE,
        drop: Math.random() < 0.65,
      });
    }
  }

  _spawnBoss(wave) {
    this.bossMode = true;
    const bossData = STORY_DATA.bosses[wave];
    const hp = 300 + wave * 60;
    const col  = bossData ? bossData.color : 0xff1133;
    const name = bossData ? bossData.name  : 'BOSS';

    this.boss = {
      x: W / 2, y: -90, targetY: 130,
      vx: 0, vy: 1.5,
      hp, maxHp: hp, w: 88, h: 72,
      phase: 0, atkTimer: 0, atkIdx: 0, t: 0,
      score: 6000 + wave * 600,
      mc: col, ac: this._darken(col),
    };
    this.txtBossName.setText(name).setAlpha(1);
    if (bossData) {
      this.txtBossName.setColor(
        wave === 5  ? '#44aaff' :
        wave === 10 ? '#aa44ff' : '#ff2244'
      );
    }
  }

  _darken(col) {
    const r = ((col >> 16) & 0xff) * 0.6 | 0;
    const g = ((col >> 8) & 0xff) * 0.6 | 0;
    const b = (col & 0xff) * 0.6 | 0;
    return (r << 16) | (g << 8) | b;
  }

  // ── Bullet firing ────────────────────────────────────────────
  _firePBullet(x, y, angle = -Math.PI / 2, spd = 520) {
    this.pBullets.push({ x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, w: 4, h: 14 });
  }

  _fireEBullet(x, y, angle, spd = 190, col = C.RED) {
    this.eBullets.push({ x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, col, w: 7, h: 7 });
  }

  _aimAtPlayer(x, y, spd = 175, col = C.RED) {
    const ang = Math.atan2(this.player.y - y, this.player.x - x);
    this._fireEBullet(x, y, ang, spd, col);
  }

  _playerShoot() {
    const { x, y } = this.player;
    SFX.shoot();
    if (this.wepLv === 1) {
      this._firePBullet(x, y - 14);
    } else if (this.wepLv === 2) {
      this._firePBullet(x - 9, y - 10); this._firePBullet(x + 9, y - 10);
    } else {
      this._firePBullet(x, y - 14);
      this._firePBullet(x - 11, y - 8); this._firePBullet(x + 11, y - 8);
      this._firePBullet(x - 18, y - 2, -Math.PI / 2 - 0.22);
      this._firePBullet(x + 18, y - 2, -Math.PI / 2 + 0.22);
    }
  }

  _useBomb() {
    if (this.bombs <= 0) return;
    this.bombs--;
    this._updateBombText();
    this.eBullets = [];
    for (const e of this.enemies) { this._explode(e.x, e.y, 2); e.hp = 0; }
    if (this.boss) { this.boss.hp -= 40; this._explode(this.boss.x, this.boss.y, 3); }
    this.flashAlpha = 0.55;
    this._shake(16, 350);
    SFX.explode(3);
    this.comms.sendRandom('bombUse');
  }

  // ── Particles ────────────────────────────────────────────────
  _explode(x, y, size = 1) {
    const cols = [C.CYAN, C.MAGENTA, C.YELLOW, C.ORANGE, C.WHITE];
    const n = ~~(8 + size * 10);
    for (let i = 0; i < n; i++) {
      const ang = Math.random() * Math.PI * 2;
      const spd = (50 + Math.random() * 160) * size;
      this.particles.push({
        type: 'spark', x, y,
        vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
        life: 1, decay: 0.014 + Math.random() * 0.018,
        sz: (1.5 + Math.random() * 4) * size * 0.5,
        col: cols[~~(Math.random() * cols.length)],
      });
    }
    this.particles.push({ type: 'ring', x, y, r: 5, maxR: 45 * size, life: 1, decay: 0.035, col: C.WHITE });
  }

  _hitSpark(x, y, col = C.WHITE) {
    for (let i = 0; i < 6; i++) {
      const ang = Math.random() * Math.PI * 2;
      this.particles.push({ type: 'spark', x, y, vx: Math.cos(ang) * 130, vy: Math.sin(ang) * 130, life: 1, decay: 0.075, sz: 1.8, col });
    }
  }

  _shake(intens, ms) {
    if (!this._shk) this._shk = { i: 0, ms: 0 };
    this._shk.i  = Math.max(this._shk.i, intens);
    this._shk.ms = Math.max(this._shk.ms, ms);
  }

  _hit(ax, ay, aw, ah, bx, by, bw, bh) {
    return Math.abs(ax - bx) < (aw + bw) * 0.5 && Math.abs(ay - by) < (ah + bh) * 0.5;
  }

  // ── Powerups ──────────────────────────────────────────────────
  _dropPowerup(x, y) {
    const types = ['weapon', 'shield', 'bomb', 'life'];
    const w = [45, 25, 20, 10];
    let r = Math.random() * 100, type = 'weapon';
    for (let i = 0; i < types.length; i++) { r -= w[i]; if (r <= 0) { type = types[i]; break; } }
    const cols = { weapon: C.YELLOW, shield: C.CYAN, bomb: C.ORANGE, life: C.GREEN };
    this.powerups.push({ x, y, type, vy: 58, timer: 0, col: cols[type] });
  }

  _collectPowerup(p) {
    SFX.powerup();
    this.comms.sendRandom('powerup');
    switch (p.type) {
      case 'weapon':
        this.wepExp += 35;
        if (this.wepExp >= 100 && this.wepLv < 3) {
          this.wepLv++; this.wepExp = 0;
          this.txtWepLv.setText(`LV.${this.wepLv}`);
          SFX.levelup();
          this._floatText(this.player.x, this.player.y - 35, 'WEAPON UP!', '#ffee00');
        } else if (this.wepLv >= 3) this.wepExp = 100;
        break;
      case 'shield':
        this.shieldOn = true; this.shieldMs = 5500;
        this._floatText(this.player.x, this.player.y - 35, 'SHIELD ON', '#00ffff');
        break;
      case 'bomb':
        this.bombs = Math.min(this.bombs + 1, 5);
        this._updateBombText();
        this._floatText(this.player.x, this.player.y - 35, 'BOMB +1', '#ff7700');
        break;
      case 'life':
        this.lives = Math.min(this.lives + 1, 5);
        this.txtLives.setText('♦'.repeat(this.lives));
        this._floatText(this.player.x, this.player.y - 35, 'LIFE +1', '#00ff99');
        break;
    }
  }

  _floatText(x, y, msg, col) {
    const t = this.add.text(x, y, msg, {
      fontFamily: 'Orbitron, monospace', color: col, fontSize: '13px',
      stroke: '#000', strokeThickness: 3,
    }).setOrigin(0.5).setDepth(30);
    this.tweens.add({ targets: t, y: y - 55, alpha: 0, duration: 1100, ease: 'Power2', onComplete: () => t.destroy() });
  }

  // ── Combo & score ─────────────────────────────────────────────
  _addScore(pts) {
    const mult = Math.min(Math.max(this.combo, 1), 12);
    const final = pts * mult;
    this.score += final;
    this.txtScore.setText(`SCORE  ${this.score.toLocaleString()}`);
    if (mult >= 2)
      this._floatText(this.player.x + Phaser.Math.Between(-40, 40), this.player.y - 20,
        `+${final.toLocaleString()}`, '#ffee00');
  }

  _killEnemy(e, idx) {
    this._addScore(e.score);
    this.combo++;
    this.comboTimer = 2200;
    if (this.combo >= 4)
      this.txtCombo.setText(`${this.combo} CHAIN  ×${Math.min(this.combo, 12)}`);
    this._explode(e.x, e.y, e.type === 'bomber' ? 2.5 : 1);
    this._shake(e.type === 'bomber' ? 10 : 4, 200);
    SFX.explode(e.type === 'bomber' ? 2 : 1);
    if (e.drop || Math.random() < 0.12) this._dropPowerup(e.x, e.y);
    this.cloakGauge = Math.min(this.cloakGauge + (e.type === 'bomber' ? 12 : e.type === 'fighter' ? 6 : 3), this.cloakMax);
    this.wepExp = Math.min(this.wepExp + 6, 100);
    if (this.wepExp >= 100 && this.wepLv < 3) {
      this.wepLv++; this.wepExp = 0;
      this.txtWepLv.setText(`LV.${this.wepLv}`);
      SFX.levelup();
    }
    this.enemies.splice(idx, 1);
    // Combo comms
    if (this.combo === 5)  this.comms.sendRandom('combo5');
    if (this.combo === 10) this.comms.sendRandom('combo10');
    if (this.combo === 20) this.comms.sendRandom('combo20');
  }

  _killBoss() {
    const b = this.boss;
    this._addScore(b.score);
    this.combo += 5; this.comboTimer = 3000;
    for (let i = 0; i < 6; i++)
      this.time.delayedCall(i * 200, () => {
        if (!b) return;
        this._explode(b.x + Phaser.Math.Between(-45, 45), b.y + Phaser.Math.Between(-30, 30), 3);
        SFX.explode(3); this._shake(22, 300);
      });
    this._dropPowerup(b.x - 40, b.y);
    this._dropPowerup(b.x, b.y);
    this._dropPowerup(b.x + 40, b.y);
    this._floatText(W / 2, H / 2 - 50, `${b.mc === STORY_DATA.bosses[this.wave]?.color ? (STORY_DATA.bosses[this.wave]?.name || 'BOSS') : 'BOSS'}  DESTROYED`, '#ff2244');

    const wave = this.wave;
    this.boss = null;
    this.bossMode = false;
    this.cloakGauge = this.cloakMax;  // Full recharge on boss kill
    this.waveCleared = true;  // _updateWaveProgressによる二重遷移を防止
    this.txtBossName.setAlpha(0);

    if (wave === 15) {
      // Final boss → Ending
      this.time.delayedCall(2000, () => {
        this.cameras.main.fadeOut(1200, 0, 0, 0);
        this.time.delayedCall(1200, () => this.scene.start('Ending', { score: this.score }));
      });
    } else {
      // Show defeat dialog then continue
      const defeatLines = STORY_DATA.bosses[wave]?.defeatLines;
      if (defeatLines && defeatLines.length > 0) {
        this.time.delayedCall(2000, () => {
          this.dialogActive = true;
          this.dialog.start(defeatLines, () => {
            this.dialogActive = false;
            this.time.delayedCall(1000, () => this._startWave(wave + 1));
          });
        });
      } else {
        this.time.delayedCall(2800, () => this._startWave(wave + 1));
      }
    }
  }

  _hitPlayer() {
    if (!this.player.alive || this.invincible) return;
    if (this.shieldOn) {
      this.shieldOn = false; SFX.shield();
      this._shake(8, 280); this._explode(this.player.x, this.player.y, 0.8);
      this._floatText(this.player.x, this.player.y - 30, 'SHIELD BREAK', '#00ffff');
      return;
    }
    this.lives--;
    this.txtLives.setText('♦'.repeat(Math.max(0, this.lives)));
    this.combo = 0; this.comboTimer = 0; this.txtCombo.setText('');
    this.wepLv = Math.max(1, this.wepLv - 1);
    this.txtWepLv.setText(`LV.${this.wepLv}`);
    this.flashAlpha = 0.5;
    this._explode(this.player.x, this.player.y, 1.8);
    this._shake(16, 400);
    SFX.explode(2);
    if (this.lives <= 0) {
      this.player.alive = false;
      this.comms.sendRandom('death');
      this.time.delayedCall(1600, () => this._endGame());
    } else {
      this.invincible = true; this.invMs = 2800;
      this.comms.sendRandom('hit');
      this._floatText(this.player.x, this.player.y - 40, 'DAMAGED!', '#ff2244');
    }
  }

  _endGame() {
    this.over = true;
    this.cameras.main.fadeOut(800, 0, 0, 0);
    this.time.delayedCall(800, () =>
      this.scene.start('GameOver', { score: this.score, wave: this.wave })
    );
  }

  _updateBombText() {
    this.txtBombs.setText(('◈ ').repeat(this.bombs).trim() || '—');
  }

  // ── Main loop ─────────────────────────────────────────────────
  update(time, dt) {
    if (this.over) return;
    const s = dt / 1000;

    // Story UI updates (always)
    this.dialog.update(dt);
    this.comms.update(dt);

    this._updateShake(dt);
    this._updateInput(s, dt);

    // Pause gameplay during dialog
    if (!this.dialogActive) {
      this._updatePlayerBullets(s, dt);
      this._updateEnemies(s, dt);
      this._updateEnemyBullets(s, dt);
      this._updateBoss(s, dt);
      this._updatePowerups(s, dt);
      this._updateSpawn(dt);
      this._updateWaveProgress(dt);
    }

    this._updateParticles(s);
    this._updateCombo(dt);
    this._updateShield(dt);
    this._render(dt);
  }

  _updateShake(dt) {
    if (!this._shk) return;
    if (this._shk.ms > 0) {
      this._shk.ms -= dt; this._shk.i *= 0.88;
      this.cameras.main.setScroll(
        (Math.random() - 0.5) * 2 * this._shk.i,
        (Math.random() - 0.5) * 2 * this._shk.i);
    } else { this.cameras.main.setScroll(0, 0); }
  }

  _updateInput(s, dt) {
    const p = this.player;
    const K = this.keys, Cur = this.cursors;
    const T = TOUCH_INPUT;

    // Bomb just-pressed detection
    T.bombJust = T.bomb && !T._bombPrev;
    T._bombPrev = T.bomb;

    // Dialog: Space or tap advances, everything else blocked
    if (this.dialogActive) {
      if (Phaser.Input.Keyboard.JustDown(K.SPACE)) this.dialog.advance();
      return;
    }

    if (!p.alive) return;
    let dx = 0, dy = 0;
    // Keyboard
    if (K.A.isDown || Cur.left.isDown)  dx -= 1;
    if (K.D.isDown || Cur.right.isDown) dx += 1;
    if (K.W.isDown || Cur.up.isDown)    dy -= 1;
    if (K.S.isDown || Cur.down.isDown)  dy += 1;
    // Touch joystick (HTML controls) - boosted curve for responsiveness
    if (IS_MOBILE && (Math.abs(T.dx) > 0.05 || Math.abs(T.dy) > 0.05)) {
      // Apply power curve: small tilt → already fast
      const tdx = Math.sign(T.dx) * Math.pow(Math.abs(T.dx), 0.55);
      const tdy = Math.sign(T.dy) * Math.pow(Math.abs(T.dy), 0.55);
      dx += tdx; dy += tdy;
    }
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len > 1) { dx /= len; dy /= len; }

    const spdMul = IS_MOBILE ? 1.15 : 1.0;
    p.x = Phaser.Math.Clamp(p.x + dx * p.spd * spdMul * s, p.w, W - p.w);
    p.y = Phaser.Math.Clamp(p.y + dy * p.spd * spdMul * s, p.h, H - 36);
    p.tilt += (dx * 0.7 - p.tilt) * 0.18;

    const fr = this.wepLv === 3 ? 95 : this.wepLv === 2 ? 135 : 175;
    p.cooldown -= dt;
    const firing = K.SPACE.isDown || Cur.space?.isDown || T.fire;
    if (firing && p.cooldown <= 0) {
      this._playerShoot(); p.cooldown = fr;
    }
    if (Phaser.Input.Keyboard.JustDown(K.Z) || T.bombJust) this._useBomb();

    // Invisible cloak
    const cloakHeld = K.X.isDown || T.cloak;
    if (cloakHeld && this.cloakGauge > 0 && !this.cloakOn) {
      this.cloakOn = true;
    }
    if (this.cloakOn) {
      this.cloakGauge -= this.cloakDrain * (dt / 1000);
      if (this.cloakGauge <= 0 || !cloakHeld) {
        this.cloakGauge = Math.max(0, this.cloakGauge);
        this.cloakOn = false;
      }
    }

    if (this.invincible) { this.invMs -= dt; if (this.invMs <= 0) this.invincible = false; }
  }

  _updatePlayerBullets(s) {
    for (let i = this.pBullets.length - 1; i >= 0; i--) {
      const b = this.pBullets[i];
      b.x += b.vx * s; b.y += b.vy * s;
      if (b.y < -20 || b.x < -80 || b.x > W + 80) { this.pBullets.splice(i, 1); continue; }
      let hit = false;
      for (let j = this.enemies.length - 1; j >= 0; j--) {
        const e = this.enemies[j];
        if (this._hit(b.x, b.y, b.w, b.h, e.x, e.y, e.w * 0.85, e.h * 0.85)) {
          e.hp--; this._hitSpark(b.x, b.y, C.CYAN);
          this.pBullets.splice(i, 1); hit = true;
          if (e.hp <= 0) this._killEnemy(e, j);
          break;
        }
      }
      if (hit) continue;
      if (this.boss && this.boss.phase > 0 &&
          this._hit(b.x, b.y, b.w, b.h, this.boss.x, this.boss.y, this.boss.w * 0.88, this.boss.h * 0.88)) {
        this.boss.hp--; this._hitSpark(b.x, b.y, C.YELLOW);
        this.pBullets.splice(i, 1);
        if (this.boss.hp <= 0) this._killBoss();
      }
    }
  }

  _updateEnemies(s, dt) {
    const now = Date.now();
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      const e = this.enemies[i];
      const EL = e.w, ER = W - e.w;  // same margin as player
      if (e.type === 'scout') {
        e.x += e.vx + Math.sin(now * 0.0028 + e.ph) * 0.85;
        e.y += e.vy;
        if (e.x < EL || e.x > ER) e.vx *= -1;
        e.x = Phaser.Math.Clamp(e.x, EL, ER);
      } else if (e.type === 'fighter') {
        e.x += e.vx * s;
        e.y += e.vy * s + Math.sin(now * e.sineSpd + e.ph) * 0.9;
        e.dist += Math.abs(e.vx * s);
        if (e.x <= EL) { e.vx = Math.abs(e.vx); e.x = EL; }
        if (e.x >= ER) { e.vx = -Math.abs(e.vx); e.x = ER; }
      } else if (e.type === 'bomber') {
        e.x += e.vx; e.y += e.vy;
        e.vx += Math.sin(now * 0.0018 + e.ph) * 0.04;
        e.vx = Phaser.Math.Clamp(e.vx, -1.1, 1.1);
        if (e.x < EL) e.vx = Math.abs(e.vx);
        if (e.x > ER) e.vx = -Math.abs(e.vx);
        e.x = Phaser.Math.Clamp(e.x, EL, ER);
      }
      if (e.y > H + 60) { this.enemies.splice(i, 1); continue; }
      e.shootMs -= dt;
      if (e.shootMs <= 0) {
        this._aimAtPlayer(e.x, e.y, e.type === 'bomber' ? 155 : 175);
        if (e.type === 'bomber') {
          this._aimAtPlayer(e.x - 8, e.y + 5, 140);
          this._aimAtPlayer(e.x + 8, e.y + 5, 140);
        }
        e.shootMs = e.shootRate;
      }
      const immune = this.invincible || this.cloakOn;
      if (!immune && this.player.alive &&
          this._hit(e.x, e.y, e.w * 0.7, e.h * 0.7, this.player.x, this.player.y, this.player.w * 0.65, this.player.h * 0.65)) {
        this._explode(e.x, e.y, 1.5); this.enemies.splice(i, 1);
        this._hitPlayer();
      }
    }
  }

  _updateEnemyBullets(s) {
    for (let i = this.eBullets.length - 1; i >= 0; i--) {
      const b = this.eBullets[i];
      b.x += b.vx * s; b.y += b.vy * s;
      if (b.y > H + 25 || b.y < -25 || b.x < -25 || b.x > W + 25) { this.eBullets.splice(i, 1); continue; }
      const immune = this.invincible || this.cloakOn;
      if (!immune && this.player.alive &&
          this._hit(b.x, b.y, b.w, b.h, this.player.x, this.player.y, this.player.w * 0.55, this.player.h * 0.55)) {
        this.eBullets.splice(i, 1);
        this._hitPlayer();
      }
    }
  }

  // ── Boss dispatcher ─────────────────────────────────────
  _updateBoss(s, dt) {
    const b = this.boss;
    if (!b) return;
    b.t += dt;
    // 降下中は共通
    if (b.y < b.targetY) { b.y += b.vy; return; }
    if (b.phase === 0) { b.phase = 1; SFX.bossAlert(); }
    // ボス別ロジックへ分岐
    if (this.wave === 5)       this._updateBossGuardian(b, s, dt);
    else if (this.wave === 10) this._updateBossOracle(b, s, dt);
    else if (this.wave === 15) this._updateBossNexus(b, s, dt);
    else                       this._updateBossDefault(b, s, dt);
  }

  // ── GUARDIAN (Wave 5) — 近距離突進型 ────────────────────
  _updateBossGuardian(b, s, dt) {
    const hpPct = b.hp / b.maxHp;
    // Phase遷移
    if (hpPct < 0.6 && b.phase === 1) {
      b.phase = 2; b.targetY = 200;
      this._floatText(W / 2, H / 2, '—  ENRAGED  —', '#ff2244');
      this._shake(20, 500);
      const bd = STORY_DATA.bosses[this.wave];
      if (bd && bd.rageLine) this.comms.send(bd.name, bd.rageLine, 5);
    }
    if (hpPct < 0.3 && b.phase === 2) {
      b.phase = 3; b.targetY = 250;
      this._floatText(W / 2, H / 2, '—  OVERDRIVE  —', '#ff4400');
      this._shake(28, 600);
    }
    // 状態初期化
    if (b.charging == null) {
      b.charging = false; b.chargePhase = 0; b.chargeTimer = 0;
      b.chargeCooldown = 0; b.chargeTarget = {x:0,y:0}; b.chargeReturn = {x:0,y:0};
      b.mines = []; b.spiralAngle = 0;
    }
    // 設置弾(mine)更新
    for (let i = b.mines.length - 1; i >= 0; i--) {
      const m = b.mines[i]; m.timer -= dt;
      if (m.timer <= 0) {
        for (let a = 0; a < 8; a++) this._fireEBullet(m.x, m.y, (a/8)*Math.PI*2, 155, 0x66ccff);
        this._shake(6, 150); b.mines.splice(i, 1);
      }
    }
    // 移動
    if (b.charging) {
      const ct = b.chargeTarget;
      const cspd = b.phase === 3 ? 650 : 460;
      if (b.chargePhase === 0) {
        const dx = ct.x - b.x, dy = ct.y - b.y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if (dist < 20) {
          b.chargePhase = 1; b.chargeTimer = 200;
          if (b.phase >= 2) b.mines.push({x:b.x, y:b.y, timer:1500});
        } else {
          b.x += (dx/dist)*cspd*s; b.y += (dy/dist)*cspd*s;
          b.chargeTimer += dt;
          if (b.chargeTimer > 80) {
            b.chargeTimer = 0;
            if (b.phase === 3) {
              for (let a = 0; a < 5; a++) this._fireEBullet(b.x, b.y, Math.random()*Math.PI*2, 110+Math.random()*70, b.mc);
            } else {
              const ma = Math.atan2(dy, dx);
              this._fireEBullet(b.x, b.y, ma+Math.PI/2, 145, b.mc);
              this._fireEBullet(b.x, b.y, ma-Math.PI/2, 145, b.mc);
            }
          }
        }
      } else {
        b.chargeTimer -= dt;
        if (b.chargeTimer <= 0) {
          const rx = b.chargeReturn.x, ry = b.chargeReturn.y;
          const dx = rx-b.x, dy = ry-b.y, dist = Math.sqrt(dx*dx+dy*dy);
          if (dist < 15) { b.charging = false; b.chargeCooldown = b.phase===3?1200:b.phase===2?2000:3000; }
          else { b.x += (dx/dist)*300*s; b.y += (dy/dist)*300*s; }
        }
      }
    } else {
      if (Math.abs(b.y - b.targetY) > 2) b.y += (b.targetY - b.y) * 0.02;
      if (b.phase === 1) b.x = W/2 + Math.sin(b.t*0.0018)*(W*0.38);
      else if (b.phase === 2) b.x = W/2 + Math.sin(b.t*0.0022)*(W*0.32);
      else { b.x = W/2 + Math.sin(b.t*0.0035)*( W*0.35); b.y = b.targetY + Math.sin(b.t*0.0025)*80; }
      b.chargeCooldown -= dt;
      if (b.chargeCooldown <= 0) {
        const freq = b.phase===3?2:b.phase===2?3:4;
        if (b.atkIdx % freq === freq-1) {
          b.charging = true; b.chargePhase = 0; b.chargeTimer = 0;
          b.chargeReturn = {x:b.x, y:b.y};
          b.chargeTarget = {x:this.player.x, y:Math.min(this.player.y-40, H*0.75)};
          this._shake(8, 200);
        }
      }
    }
    b.x = Math.max(b.w/2, Math.min(W-b.w/2, b.x));
    b.y = Math.max(40, Math.min(H*0.8, b.y));
    // 攻撃
    if (!b.charging) {
      b.atkTimer -= dt;
      if (b.atkTimer <= 0) {
        const pat = b.atkIdx % (b.phase===3?5:b.phase===2?4:3);
        if (pat === 0) {
          // 高速3連狙い撃ち
          for (let k=0;k<3;k++) this.time.delayedCall(k*100, ()=>{ if(this.boss) this._aimAtPlayer(this.boss.x, this.boss.y+28, 310, this.boss.mc); });
        } else if (pat === 1) {
          // Vフォーメーション弾
          const ba = Math.atan2(this.player.y-b.y, this.player.x-b.x);
          [-0.7,-0.35,0,0.35,0.7].forEach((off,i)=>this._fireEBullet(b.x, b.y+28, ba+off, [270,230,260,230,270][i], b.mc));
        } else if (pat === 2) {
          // サイド付き狙い撃ち
          this._aimAtPlayer(b.x, b.y+28, 280, b.mc);
          this._fireEBullet(b.x-30, b.y+20, Math.PI*0.6, 175, b.ac);
          this._fireEBullet(b.x+30, b.y+20, Math.PI*0.4, 175, b.ac);
        } else if (pat === 3) {
          // Ring弾 (Phase2+)
          const n = b.phase===3?14:10;
          for (let a=0;a<n;a++) this._fireEBullet(b.x, b.y, (a/n)*Math.PI*2+b.t*0.002, 140, b.ac);
        } else if (pat === 4) {
          // 3-way連射+螺旋弾 (Phase3)
          for (let k=0;k<4;k++) this.time.delayedCall(k*110, ()=>{
            if(!this.boss) return;
            const ba = Math.atan2(this.player.y-this.boss.y, this.player.x-this.boss.x);
            [-0.25,0,0.25].forEach(o=>this._fireEBullet(this.boss.x, this.boss.y+28, ba+o, 290, this.boss.mc));
          });
          for (let k=0;k<6;k++) this.time.delayedCall(k*70, ()=>{
            if(!this.boss) return; b.spiralAngle += 0.55;
            this._fireEBullet(this.boss.x, this.boss.y, b.spiralAngle, 165, 0x88ddff);
            this._fireEBullet(this.boss.x, this.boss.y, b.spiralAngle+Math.PI, 165, 0x88ddff);
          });
        }
        b.atkIdx++;
        b.atkTimer = b.phase===3?950:b.phase===2?1400:2000;
      }
    }
    // 接触判定
    const immune = this.invincible || this.cloakOn;
    if (!immune && b.phase > 0 && this.player.alive &&
        this._hit(b.x, b.y, b.w*0.75, b.h*0.75, this.player.x, this.player.y, this.player.w*0.6, this.player.h*0.6))
      this._hitPlayer();
  }

  // ── ORACLE (Wave 10) — 予測弾幕型 ──────────────────────
  _updateBossOracle(b, s, dt) {
    const hpPct = b.hp / b.maxHp;
    // Phase遷移
    if (hpPct < 0.65 && b.phase === 1) {
      b.phase = 2;
      this._floatText(W / 2, H / 2, '—  PREDICTION  —', '#cc66ff');
      this._shake(18, 450);
    }
    if (hpPct < 0.30 && b.phase === 2) {
      b.phase = 3;
      this._floatText(W / 2, H / 2, '—  OMNISCIENCE  —', '#dd44ff');
      this._shake(25, 600);
      const bd = STORY_DATA.bosses[this.wave];
      if (bd && bd.rageLine) this.comms.send(bd.name, bd.rageLine, 5);
    }
    // 状態初期化
    if (b.spiralAngle == null) {
      b.spiralAngle = 0; b.spiralTimer = 0; b.flowerAngle = 0;
      b.prevPX = this.player.x; b.prevPY = this.player.y;
      b.predTimer = 0; b.laserAccum = 0; b.laserAngle = 0;
    }
    // 移動: ORACLEはほぼ静止→ゆっくり→固定
    if (b.phase === 1) { b.x = W/2 + Math.sin(b.t*0.0004)*8; b.y = b.targetY + Math.sin(b.t*0.0006)*5; }
    else if (b.phase === 2) { b.x = W/2 + Math.sin(b.t*0.0008)*(W*0.18); b.y = b.targetY + Math.sin(b.t*0.0005)*8; }
    else { b.x += (W/2 - b.x)*0.03; b.y += (b.targetY-15 - b.y)*0.03; }
    // プレイヤー速度推定
    const pvx = (this.player.x - b.prevPX) / Math.max(s, 0.001);
    const pvy = (this.player.y - b.prevPY) / Math.max(s, 0.001);
    b.prevPX = this.player.x; b.prevPY = this.player.y;
    // メイン攻撃
    b.atkTimer -= dt;
    if (b.atkTimer <= 0) {
      const pat = b.atkIdx % (b.phase===1?3:b.phase===2?4:5);
      if (pat === 0) {
        // 花弾（薔薇曲線）
        const petals = b.phase===1?3:5;
        const steps = b.phase>=3?40:28;
        for (let i=0;i<steps;i++) {
          const theta = (i/steps)*Math.PI*2 + b.flowerAngle;
          const r = Math.abs(Math.cos(petals*theta))*180;
          const spd = 75 + r*0.4;
          this._fireEBullet(b.x+Math.cos(theta)*r*0.12, b.y+Math.sin(theta)*r*0.12, theta, spd, b.mc);
        }
        b.flowerAngle += 0.35;
      } else if (pat === 1) {
        // 扇状狙い撃ち
        const ba = Math.atan2(this.player.y-b.y, this.player.x-b.x);
        const n = b.phase>=2?5:3;
        for (let i=-Math.floor(n/2);i<=Math.floor(n/2);i++) this._fireEBullet(b.x, b.y+32, ba+i*0.18, 185, b.mc);
      } else if (pat === 2) {
        // 全方位Ring弾
        const n = b.phase>=3?20:14;
        for (let i=0;i<n;i++) {
          this._fireEBullet(b.x, b.y, (i/n)*Math.PI*2+b.t*0.0001, 115, b.mc);
          if (b.phase>=3) this._fireEBullet(b.x, b.y, (i/n)*Math.PI*2+Math.PI/n, 85, b.mc);
        }
      } else if (pat === 3) {
        // 偏差射撃（Phase2+）: 0.4秒先を予測
        const predX = Math.max(20, Math.min(W-20, this.player.x + pvx*0.4));
        const predY = Math.max(20, Math.min(H-20, this.player.y + pvy*0.4));
        const ang = Math.atan2(predY-b.y, predX-b.x);
        for (let k=0;k<4;k++) this.time.delayedCall(k*80, ()=>{
          if(!this.boss) return;
          this._fireEBullet(this.boss.x, this.boss.y+32, ang+(k-1.5)*0.06, 235, 0xddaaff);
        });
      } else if (pat === 4) {
        // 設置+展開弾（Phase3）
        [{x:W*0.2,y:H*0.35},{x:W*0.5,y:H*0.25},{x:W*0.8,y:H*0.35}].forEach(pos=>{
          const a = Math.atan2(pos.y-b.y, pos.x-b.x);
          const d = Math.sqrt((pos.x-b.x)**2+(pos.y-b.y)**2);
          this._fireEBullet(b.x, b.y, a, d/2, 0xeeddff);
        });
        this.time.delayedCall(2000, ()=>{
          if(!this.boss) return;
          [{x:W*0.2,y:H*0.35},{x:W*0.5,y:H*0.25},{x:W*0.8,y:H*0.35}].forEach(pos=>{
            for (let i=0;i<14;i++) this._fireEBullet(pos.x, pos.y, (i/14)*Math.PI*2, 125, this.boss.mc);
          });
          this._shake(8, 200);
        });
      }
      b.atkIdx++;
      b.atkTimer = b.phase===1?2200:b.phase===2?1700:1300;
    }
    // 螺旋弾（Phase2+）常時
    if (b.phase >= 2) {
      b.spiralTimer -= dt;
      if (b.spiralTimer <= 0) {
        for (let a=0;a<2;a++) this._fireEBullet(b.x, b.y, b.spiralAngle+(a*Math.PI), b.phase===3?130:105, b.mc);
        b.spiralAngle += 0.12;
        b.spiralTimer = b.phase===3?90:130;
      }
    }
    // 偏差単発（Phase2+）独立タイマー
    if (b.phase >= 2) {
      b.predTimer -= dt;
      if (b.predTimer <= 0) {
        const px = Math.max(20, Math.min(W-20, this.player.x+pvx*0.4));
        const py = Math.max(20, Math.min(H-20, this.player.y+pvy*0.4));
        this._fireEBullet(b.x, b.y+32, Math.atan2(py-b.y, px-b.x), 215, 0xddaaff);
        b.predTimer = b.phase===3?500:850;
      }
    }
    // 擬似レーザー（Phase3）
    if (b.phase === 3) {
      b.laserAngle += 0.28 * s;
      b.laserAccum += dt;
      while (b.laserAccum >= 40) {
        b.laserAccum -= 40;
        for (let a=0;a<4;a++) this._fireEBullet(b.x, b.y, b.laserAngle+(a*Math.PI/2), 340, 0xffaaff);
      }
    }
    // 接触判定
    const immune = this.invincible || this.cloakOn;
    if (!immune && b.phase > 0 && this.player.alive &&
        this._hit(b.x, b.y, b.w*0.75, b.h*0.75, this.player.x, this.player.y, this.player.w*0.6, this.player.h*0.6))
      this._hitPlayer();
  }

  // ── NEXUS CORE (Wave 15) — 最終ボス 4Phase ──────────────
  _updateBossNexus(b, s, dt) {
    const hpPct = b.hp / b.maxHp;
    // Phase遷移
    if (hpPct <= 0.70 && b.phase === 1) {
      b.phase = 2; b.atkTimer = 800; b.atkIdx = 0;
      this._floatText(W/2, H/2, '—  ORACLE PROTOCOL  —', '#aa44ff');
      this._shake(18, 500);
    }
    if (hpPct <= 0.40 && b.phase === 2) {
      b.phase = 3; b.atkTimer = 600; b.atkIdx = 0; b.targetY = H/2-80;
      this._floatText(W/2, H/2, '—  CONVERGENCE  —', '#ff8800');
      this._shake(24, 600);
      const bd = STORY_DATA.bosses[this.wave];
      if (bd && bd.rageLine) this.comms.send(bd.name, bd.rageLine, 5);
    }
    if (hpPct <= 0.15 && b.phase === 3) {
      b.phase = 4; b.atkTimer = 400; b.atkIdx = 0;
      this._floatText(W/2, H/2, '—  NEXUS PROTOCOL  —', '#ff1133');
      this._shake(30, 800);
    }
    // 状態初期化
    if (b.spiralAngle == null) {
      b.spiralAngle = 0; b.laserAngle = 0;
      b.splitBullets = []; b.moveTarget = {x:W/2, y:b.targetY};
      b.moveTimer = 0; b.safeX = W/2; b.safeDriftDir = 1;
    }
    // 移動
    if (b.phase <= 2) {
      const spd = b.phase===2?1.8:1.2;
      const tx = W/2 + Math.sin(b.t*0.001*spd)*(W*0.34);
      b.x += (tx - b.x)*0.04;
      b.y += (b.targetY - b.y)*0.02;
    } else if (b.phase === 3) {
      b.y += (b.targetY - b.y)*0.03;
      const tx = W/2 + Math.sin(b.t*0.002)*(W*0.42);
      b.x += (tx - b.x)*0.05;
    } else {
      b.moveTimer -= dt;
      if (b.moveTimer <= 0) {
        b.moveTarget.x = 60+Math.random()*(W-120);
        b.moveTarget.y = 60+Math.random()*(H/2-60);
        b.moveTimer = 800+Math.random()*1200;
      }
      b.x += (b.moveTarget.x - b.x)*0.06;
      b.y += (b.moveTarget.y - b.y)*0.06;
    }
    // 分裂弾更新
    for (let i=b.splitBullets.length-1;i>=0;i--) {
      const sb = b.splitBullets[i]; sb.timer -= dt;
      if (sb.timer <= 0) {
        for (let a=0;a<4;a++) this._fireEBullet(sb.x, sb.y, sb.baseAngle+(a*Math.PI/2), 155, b.mc);
        b.splitBullets.splice(i, 1);
      } else { sb.x += sb.vx*s; sb.y += sb.vy*s; }
    }
    // 攻撃
    b.atkTimer -= dt;
    if (b.atkTimer <= 0) {
      if (b.phase === 1) {
        // GUARDIANコピー: 高速狙い撃ち+V字弾+扇状弾
        const pat = b.atkIdx % 3;
        if (pat === 0) {
          for (let k=0;k<3;k++) this.time.delayedCall(k*120, ()=>{ if(this.boss) this._aimAtPlayer(this.boss.x, this.boss.y+32, 255, this.boss.mc); });
        } else if (pat === 1) {
          const ba = Math.atan2(this.player.y-b.y, this.player.x-b.x);
          [-0.5,-0.25,0,0.25,0.5].forEach(off=>this._fireEBullet(b.x, b.y+32, ba+off, 215, b.mc));
        } else {
          for (let a=150;a<=390;a+=30) this._fireEBullet(b.x, b.y+32, a*Math.PI/180, 165, b.mc);
        }
        b.atkTimer = 1800;
      } else if (b.phase === 2) {
        // ORACLEコピー: 花弾+螺旋弾
        const pat = b.atkIdx % 3;
        if (pat === 0) {
          for (let layer=0;layer<2;layer++) {
            const off = layer*(Math.PI/12);
            for (let i=0;i<12;i++) this._fireEBullet(b.x, b.y, (i/12)*Math.PI*2+off+b.t*0.0005, 115+layer*35, 0xaa44ff);
          }
        } else if (pat === 1) {
          for (let k=0;k<8;k++) this.time.delayedCall(k*80, ()=>{
            if(!this.boss) return;
            this._fireEBullet(this.boss.x, this.boss.y, this.boss.spiralAngle, 145, 0xaa44ff);
            this._fireEBullet(this.boss.x, this.boss.y, this.boss.spiralAngle+Math.PI, 145, 0xaa44ff);
            this.boss.spiralAngle += 0.45;
          });
        } else {
          for (let i=0;i<8;i++) this._fireEBullet(b.x, b.y, (i/8)*Math.PI*2, 100, 0xaa44ff);
          for (let k=0;k<3;k++) this.time.delayedCall(k*150, ()=>{ if(this.boss) this._aimAtPlayer(this.boss.x, this.boss.y+32, 235, this.boss.mc); });
        }
        b.atkTimer = 1500;
      } else if (b.phase === 3) {
        // 混在: 十字レーザー+分裂弾+コピー技
        const pat = b.atkIdx % 5;
        if (pat === 0) {
          // 十字レーザー風
          for (let k=0;k<10;k++) this.time.delayedCall(k*60, ()=>{
            if(!this.boss) return;
            for (let a=0;a<4;a++) this._fireEBullet(this.boss.x, this.boss.y, this.boss.laserAngle+(a*Math.PI/2), 195, 0xff8800);
            this.boss.laserAngle += 0.08;
          });
        } else if (pat === 1) {
          // 分裂弾
          for (let i=0;i<5;i++) {
            const ang = Math.atan2(this.player.y-b.y, this.player.x-b.x)+(i-2)*0.3;
            b.splitBullets.push({x:b.x,y:b.y+20,vx:Math.cos(ang)*125,vy:Math.sin(ang)*125,baseAngle:ang,timer:1000});
            this._fireEBullet(b.x, b.y+20, ang, 125, 0xffaa00);
          }
        } else if (pat === 2) {
          // 高速5連狙い撃ち
          for (let k=0;k<5;k++) this.time.delayedCall(k*100, ()=>{ if(this.boss) this._aimAtPlayer(this.boss.x, this.boss.y+32, 280, this.boss.mc); });
        } else if (pat === 3) {
          // 3本腕螺旋弾
          for (let k=0;k<10;k++) this.time.delayedCall(k*70, ()=>{
            if(!this.boss) return;
            for (let a=0;a<3;a++) this._fireEBullet(this.boss.x, this.boss.y, this.boss.spiralAngle+(a*Math.PI*2/3), 135, 0xaa44ff);
            this.boss.spiralAngle += 0.35;
          });
        } else {
          // V字+花弾同時
          const ba = Math.atan2(this.player.y-b.y, this.player.x-b.x);
          [-0.6,-0.3,0,0.3,0.6].forEach(off=>this._fireEBullet(b.x, b.y+32, ba+off, 225, b.mc));
          for (let i=0;i<10;i++) this._fireEBullet(b.x, b.y, (i/10)*Math.PI*2+b.t*0.001, 105, 0xaa44ff);
        }
        b.atkTimer = 1200;
      } else {
        // Phase4: 全力+NEXUS Protocol
        const pat = b.atkIdx % 6;
        if (pat === 0 || pat === 3) {
          // NEXUS Protocol: 壁弾幕（安全地帯あり）
          const gap = 70;
          b.safeX += b.safeDriftDir*(30+Math.random()*40);
          if (b.safeX < gap+20) b.safeDriftDir = 1;
          if (b.safeX > W-gap-20) b.safeDriftDir = -1;
          for (let x=0;x<=W;x+=18) {
            if (Math.abs(x-b.safeX) < gap/2) continue;
            this._fireEBullet(x, -10, Math.PI/2, 130, 0xff1133);
          }
          this.time.delayedCall(400, ()=>{
            if(!this.boss) return;
            const sy = 200+Math.random()*300;
            for (let y=30;y<=H-30;y+=22) { if(Math.abs(y-sy)<40) continue; this._fireEBullet(-10,y,0,115,0xff1133); }
          });
        } else if (pat === 1) {
          // 高速十字レーザー
          for (let k=0;k<14;k++) this.time.delayedCall(k*45, ()=>{
            if(!this.boss) return;
            for (let a=0;a<4;a++) this._fireEBullet(this.boss.x, this.boss.y, this.boss.laserAngle+(a*Math.PI/2), 235, 0xff8800);
            this.boss.laserAngle += 0.12;
          });
        } else if (pat === 2) {
          // 高速分裂弾
          for (let i=0;i<6;i++) {
            const ang = (i/6)*Math.PI*2;
            b.splitBullets.push({x:b.x,y:b.y,vx:Math.cos(ang)*145,vy:Math.sin(ang)*145,baseAngle:ang,timer:700});
            this._fireEBullet(b.x, b.y, ang, 145, 0xffaa00);
          }
        } else if (pat === 4) {
          // 螺旋+狙い撃ち同時
          for (let k=0;k<10;k++) this.time.delayedCall(k*55, ()=>{
            if(!this.boss) return;
            for (let a=0;a<4;a++) this._fireEBullet(this.boss.x, this.boss.y, this.boss.spiralAngle+(a*Math.PI/2), 165, 0xaa44ff);
            this.boss.spiralAngle += 0.4;
          });
          for (let k=0;k<4;k++) this.time.delayedCall(k*80, ()=>{ if(this.boss) this._aimAtPlayer(this.boss.x, this.boss.y+32, 300, this.boss.mc); });
        } else {
          // 花弾+V字の集大成
          for (let layer=0;layer<3;layer++) {
            for (let i=0;i<10;i++) this._fireEBullet(b.x, b.y, (i/10)*Math.PI*2+layer*(Math.PI/10), 95+layer*30, 0xaa44ff);
          }
          const ba = Math.atan2(this.player.y-b.y, this.player.x-b.x);
          [-0.4,-0.2,0,0.2,0.4].forEach(off=>this._fireEBullet(b.x, b.y+32, ba+off, 255, b.mc));
        }
        b.atkTimer = 1000;
      }
      b.atkIdx++;
    }
    // 接触判定
    const immune = this.invincible || this.cloakOn;
    if (!immune && b.phase > 0 && this.player.alive &&
        this._hit(b.x, b.y, b.w*0.75, b.h*0.75, this.player.x, this.player.y, this.player.w*0.6, this.player.h*0.6))
      this._hitPlayer();
  }

  // ── Default boss (fallback) ─────────────────────────────
  _updateBossDefault(b, s, dt) {
    if (b.hp < b.maxHp*0.38 && b.phase === 1) {
      b.phase = 2; this._floatText(W/2, H/2, '—  ENRAGED  —', '#ff2244'); this._shake(20, 500);
    }
    const spd = b.phase === 2 ? 2.2 : 1.4;
    b.x = W/2 + Math.sin(b.t*0.001*spd)*(W*0.34);
    b.atkTimer -= dt;
    if (b.atkTimer <= 0) {
      const pat = b.atkIdx % (b.phase===2?5:3);
      if (pat===0) { for(let a=160;a<=380;a+=28) this._fireEBullet(b.x,b.y+32,a*Math.PI/180,165,b.mc); }
      else if (pat===1) { this._aimAtPlayer(b.x,b.y+32,230,b.mc); this._aimAtPlayer(b.x-32,b.y+22,205,b.mc); this._aimAtPlayer(b.x+32,b.y+22,205,b.mc); }
      else if (pat===2) { for(let a=0;a<360;a+=40) this._fireEBullet(b.x,b.y,(a+b.t*0.09)*Math.PI/180,135,b.mc); }
      else if (pat===3) { for(let k=0;k<5;k++) this.time.delayedCall(k*100,()=>{if(this.boss)this._aimAtPlayer(this.boss.x,this.boss.y+32,270,this.boss.mc);}); }
      else { [-0.4,0,0.4].forEach(off=>{this._fireEBullet(b.x,b.y+32,Math.atan2(this.player.y-b.y,this.player.x-b.x)+off,240,b.mc);}); }
      b.atkIdx++; b.atkTimer = b.phase===2?1350:2000;
    }
    const immune = this.invincible || this.cloakOn;
    if (!immune && b.phase>0 && this.player.alive &&
        this._hit(b.x,b.y,b.w*0.75,b.h*0.75,this.player.x,this.player.y,this.player.w*0.6,this.player.h*0.6))
      this._hitPlayer();
  }

  _updatePowerups(s, dt) {
    for (let i = this.powerups.length - 1; i >= 0; i--) {
      const p = this.powerups[i];
      p.y += p.vy * s; p.timer += dt;
      if (p.y > H + 30) { this.powerups.splice(i, 1); continue; }
      if (this.player.alive && this._hit(p.x, p.y, 22, 22, this.player.x, this.player.y, 30, 30)) {
        this._collectPowerup(p); this.powerups.splice(i, 1);
      }
    }
  }

  _updateParticles(s) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.life -= p.decay;
      if (p.life <= 0) { this.particles.splice(i, 1); continue; }
      if (p.type === 'spark') { p.x += p.vx * s; p.y += p.vy * s; p.vx *= 0.91; p.vy *= 0.91; }
      else if (p.type === 'ring') { p.r += (p.maxR - p.r) * 0.14; }
    }
  }

  _updateCombo(dt) {
    if (this.combo > 0) {
      this.comboTimer -= dt;
      if (this.comboTimer <= 0) { this.combo = 0; this.txtCombo.setText(''); }
    }
  }

  _updateShield(dt) {
    if (this.shieldOn) { this.shieldMs -= dt; if (this.shieldMs <= 0) this.shieldOn = false; }
  }

  _updateSpawn(dt) {
    if (this.bossMode || this.spawnQ.length === 0) return;
    this.spawnMs += dt;
    while (this.spawnQ.length > 0 && this.spawnMs >= this.spawnQ[0].delay) {
      const s = this.spawnQ.shift();
      this._spawnEnemy(s.type, s.diff);
      if (this.spawnQ.length > 0) this.spawnQ[0].delay -= s.delay;
    }
  }

  _updateWaveProgress(dt) {
    if (this.bossMode || this.waveCleared || this.dialogActive || this.spawnQ.length > 0 || this.enemies.length > 0) return;
    this.waveWait += dt;
    if (this.waveWait > 1800) {
      this.waveCleared = true;
      this._floatText(W / 2, H / 2, `WAVE  ${this.wave}  CLEAR`, '#00ff99');
      this.time.delayedCall(2000, () => {
        if (this.wave < 15) this._startWave(this.wave + 1);
        else this._endGame();
      });
    }
  }

  // ── Render ────────────────────────────────────────────────────
  _render(dt) {
    const now = Date.now();
    const bg = this.gBg;
    bg.clear();
    bg.fillStyle(C.BG, 1); bg.fillRect(0, 0, W, H);
    const st = now * 0.00018;
    bg.fillStyle(0x080025, 0.55); bg.fillCircle(W * 0.28 + Math.sin(st) * 35, H * 0.32, 165);
    bg.fillStyle(0x001614, 0.45); bg.fillCircle(W * 0.72 + Math.cos(st * 0.75) * 28, H * 0.62, 140);
    for (const s of this.stars) {
      s.y += s.spd * (dt / 16) * 0.5;
      if (s.y > H) { s.y = -4; s.x = Math.random() * W; }
      const b = 0.35 + 0.65 * (0.7 + 0.3 * Math.sin(now * 0.0018 + s.ph));
      bg.fillStyle(s.col, b); bg.fillCircle(s.x, s.y, s.r);
    }

    const g = this.gMain; g.clear();
    this._drawPlayerBullets(g);
    this._drawEnemyBullets(g, now);
    this._drawEnemies(g, now);
    this._drawBoss(g, now);
    this._drawBossExtras(g, now);
    this._drawPlayer(g, now);
    this._drawPowerups(g, now);

    const fx = this.gFx; fx.clear();
    for (const p of this.particles) {
      if (p.type === 'spark') {
        fx.fillStyle(p.col, p.life * 0.85); fx.fillCircle(p.x, p.y, p.sz * p.life);
        fx.fillStyle(p.col, p.life * 0.18); fx.fillCircle(p.x, p.y, p.sz * p.life * 2.8);
      } else if (p.type === 'ring') {
        fx.lineStyle(2.5 * p.life, p.col, p.life * 0.55); fx.strokeCircle(p.x, p.y, p.r);
      }
    }
    if (this.flashAlpha > 0) {
      fx.fillStyle(0xffffff, this.flashAlpha); fx.fillRect(0, 0, W, H);
      this.flashAlpha -= 0.035;
    }
    // Dialog pause overlay
    if (this.dialogActive) {
      fx.fillStyle(0x000000, 0.35); fx.fillRect(0, 0, W, H);
    }

    const hud = this.gHud; hud.clear();
    hud.fillStyle(0x000000, 0.55); hud.fillRect(0, 0, W, 56);
    hud.lineStyle(1, C.CYAN, 0.18); hud.lineBetween(0, 56, W, 56);
    hud.fillStyle(0x001122, 0.9); hud.fillRect(10, 47, 82, 5);
    hud.fillStyle(C.ORANGE, 0.9); hud.fillRect(10, 47, 82 * (this.wepExp / 100), 5);
    // Cloak gauge
    const cPct = this.cloakGauge / this.cloakMax;
    const cCol = this.cloakOn ? 0xaa66ff : 0x6633cc;
    hud.fillStyle(0x110022, 0.9); hud.fillRect(46, 43, 48, 4);
    hud.fillStyle(cCol, this.cloakOn ? 0.95 : 0.7); hud.fillRect(46, 43, 48 * cPct, 4);
    if (this.shieldOn) {
      hud.fillStyle(0x002233, 0.8); hud.fillRect(10, H - 16, 100, 5);
      hud.fillStyle(C.CYAN, 0.9);   hud.fillRect(10, H - 16, 100 * (this.shieldMs / 5500), 5);
    }
    if (this.bossMode && this.boss) {
      const pct = this.boss.hp / this.boss.maxHp;
      const bw = 240, bx = W / 2 - bw / 2, by = H - 28;
      hud.fillStyle(0x110000, 0.85); hud.fillRect(bx - 2, by - 2, bw + 4, 12);
      hud.lineStyle(1, this.boss.mc, 0.5); hud.strokeRect(bx - 2, by - 2, bw + 4, 12);
      hud.fillStyle(this.boss.mc, 1); hud.fillRect(bx, by, bw * pct, 8);
      hud.fillStyle(0xffffff, 0.28 * (0.4 + 0.4 * Math.sin(now * 0.008)));
      hud.fillRect(bx, by, bw * pct, 4);
      // Phase区切り線
      const marks = this.wave===5?[0.6,0.3]:this.wave===10?[0.65,0.3]:this.wave===15?[0.7,0.4,0.15]:[];
      hud.lineStyle(1, 0xffffff, 0.4);
      marks.forEach(m => hud.lineBetween(bx+bw*m, by-2, bx+bw*m, by+10));
    }
  }

  _drawPlayer(g, now) {
    const p = this.player;
    if (!p.alive) return;
    if (this.invincible && ~~(now / 90) % 2 === 0) return;
    const thr = 0.5 + 0.5 * Math.sin(now * 0.018);
    const tilt = p.tilt;
    const tx = p.x, ty = p.y;
    const leanX = tilt * 6;
    const cloaked = this.cloakOn;
    const mainCol = cloaked ? 0x8844ff : C.CYAN;
    const mainA   = cloaked ? 0.3 : 1;
    const subA    = cloaked ? 0.2 : 0.82;
    g.fillStyle(mainCol, 0.12 * thr * (cloaked ? 0.4 : 1)); g.fillEllipse(tx, ty + 22, 28, 38 * thr);
    g.fillStyle(mainCol, mainA);
    g.fillTriangle(tx + leanX, ty - 16, tx - 13, ty + 13, tx + 13, ty + 13);
    g.fillStyle(mainCol, subA);
    g.fillTriangle(tx - 13 + leanX * 0.5, ty + 2, tx - 28, ty + 16, tx - 7, ty + 13);
    g.fillTriangle(tx + 13 + leanX * 0.5, ty + 2, tx + 28, ty + 16, tx + 7, ty + 13);
    g.fillStyle(cloaked ? 0x220044 : 0x003344, mainA); g.fillEllipse(tx + leanX * 0.6, ty - 3, 9, 14);
    g.fillStyle(cloaked ? 0x6622aa : 0x0088aa, 0.6 * mainA); g.fillEllipse(tx + leanX * 0.6, ty - 4, 5, 8);
    g.lineStyle(1.5, mainCol, 0.55 * mainA);
    g.strokeTriangle(tx + leanX, ty - 16, tx - 13, ty + 13, tx + 13, ty + 13);
    g.fillStyle(cloaked ? 0x4400aa : 0x0055cc, 0.9 * thr * mainA);
    g.fillTriangle(tx - 4, ty + 13, tx + 4, ty + 13, tx + leanX * 0.3, ty + 22 + thr * 8);
    g.fillStyle(mainCol, 0.6 * thr * mainA);
    g.fillTriangle(tx - 2.5, ty + 13, tx + 2.5, ty + 13, tx + leanX * 0.2, ty + 18 + thr * 6);
    if (cloaked) {
      // Cloak shimmer effect
      const sh = 0.15 + 0.15 * Math.sin(now * 0.015);
      g.lineStyle(2, 0xaa66ff, sh); g.strokeCircle(tx, ty, 24 + Math.sin(now * 0.008) * 4);
    }
    if (this.shieldOn) {
      const pl = 0.35 + 0.35 * Math.sin(now * 0.012);
      g.lineStyle(3, C.CYAN, pl);     g.strokeCircle(tx, ty, 30);
      g.lineStyle(1, C.CYAN, pl * 0.4); g.strokeCircle(tx, ty, 38);
    }
  }

  _drawPlayerBullets(g) {
    for (const b of this.pBullets) {
      g.fillStyle(C.CYAN, 0.18); g.fillEllipse(b.x, b.y, 11, 20);
      g.fillStyle(C.CYAN, 1);    g.fillRect(b.x - 2, b.y - 7, 4, 14);
      g.fillStyle(0xffffff, 0.9); g.fillRect(b.x - 1, b.y - 8, 2, 5);
    }
  }

  _drawEnemies(g, now) {
    for (const e of this.enemies) {
      if (e.type === 'scout')   this._drawScout(g, e, now);
      else if (e.type === 'fighter') this._drawFighter(g, e, now);
      else if (e.type === 'bomber')  this._drawBomber(g, e, now);
    }
  }

  _drawScout(g, e) {
    g.fillStyle(C.CYAN, 0.07); g.fillCircle(e.x, e.y, 22);
    g.fillStyle(C.CYAN, 0.9);
    g.fillTriangle(e.x, e.y + 11, e.x - 10, e.y - 9, e.x + 10, e.y - 9);
    g.fillStyle(C.CYAN, 0.65);
    g.fillTriangle(e.x - 10, e.y - 2, e.x - 20, e.y + 8, e.x - 5, e.y + 8);
    g.fillTriangle(e.x + 10, e.y - 2, e.x + 20, e.y + 8, e.x + 5, e.y + 8);
    g.fillStyle(C.RED, 0.9); g.fillRect(e.x - 2.5, e.y - 9, 5, 4);
    g.fillStyle(0x002222, 1); g.fillCircle(e.x, e.y, 4.5);
    hpBar(g, e.x - 11, e.y - 19, 22, 3, e.hp / e.maxHp, C.GREEN, C.RED);
  }

  _drawFighter(g, e) {
    g.fillStyle(C.MAGENTA, 0.09); g.fillEllipse(e.x, e.y, 52, 32);
    g.fillStyle(C.MAGENTA, 0.9);
    g.fillTriangle(e.x, e.y + 10, e.x - 13, e.y - 10, e.x + 13, e.y - 10);
    g.fillStyle(C.MAGENTA, 0.72);
    g.fillTriangle(e.x - 13, e.y - 4, e.x - 30, e.y + 9, e.x - 5, e.y + 9);
    g.fillTriangle(e.x + 13, e.y - 4, e.x + 30, e.y + 9, e.x + 5, e.y + 9);
    g.fillStyle(0x220011, 1); g.fillEllipse(e.x, e.y, 9, 14);
    g.lineStyle(1, C.MAGENTA, 0.45);
    g.strokeTriangle(e.x, e.y + 10, e.x - 13, e.y - 10, e.x + 13, e.y - 10);
    hpBar(g, e.x - 14, e.y - 22, 28, 3, e.hp / e.maxHp, C.GREEN, C.RED);
  }

  _drawBomber(g, e, now) {
    const pulse = 0.5 + 0.5 * Math.sin(now * 0.007 + e.ph);
    g.fillStyle(C.ORANGE, 0.08); g.fillCircle(e.x, e.y, 50);
    hexagon(g, e.x, e.y, 20, C.ORANGE, 0.9);
    g.fillStyle(0xff4400, 1); g.fillCircle(e.x, e.y, 10);
    g.fillStyle(0xffaa00, 0.8); g.fillCircle(e.x, e.y, 6);
    g.lineStyle(2, C.ORANGE, pulse * 0.8); g.strokeCircle(e.x, e.y, 24);
    g.fillStyle(0xcc5500, 0.9);
    g.fillRect(e.x - 22, e.y + 5, 8, 14); g.fillRect(e.x + 14, e.y + 5, 8, 14);
    hpBar(g, e.x - 20, e.y - 34, 40, 4, e.hp / e.maxHp, C.GREEN, C.RED);
  }

  _drawBoss(g, now) {
    const b = this.boss;
    if (!b || b.phase === 0) return;
    const pulse = 0.5 + 0.5 * Math.sin(now * 0.006);
    const rage  = b.phase === 2;
    const mc = b.mc, ac = b.ac;

    g.fillStyle(mc, 0.05 * pulse); g.fillCircle(b.x, b.y, 105);
    g.fillStyle(mc, 0.1 * pulse);  g.fillCircle(b.x, b.y, 72);
    g.fillStyle(rage ? 0xff2244 : ac, 1);
    g.fillTriangle(b.x, b.y - 52, b.x - 52, b.y + 2, b.x + 52, b.y + 2);
    g.fillTriangle(b.x - 52, b.y + 2, b.x, b.y + 36, b.x + 52, b.y + 2);
    g.fillStyle(ac, 0.88);
    g.fillTriangle(b.x - 52, b.y - 8, b.x - 92, b.y + 22, b.x - 30, b.y + 22);
    g.fillTriangle(b.x + 52, b.y - 8, b.x + 92, b.y + 22, b.x + 30, b.y + 22);
    g.lineStyle(1, mc, 0.5);
    g.lineBetween(b.x - 52, b.y - 8, b.x - 92, b.y + 22);
    g.lineBetween(b.x + 52, b.y - 8, b.x + 92, b.y + 22);
    g.fillStyle(rage ? 0xffffff : mc, 1); g.fillCircle(b.x, b.y - 8, 18);
    g.fillStyle(rage ? mc : 0xff0000, 1); g.fillCircle(b.x, b.y - 8, 12);
    g.fillStyle(0xffffff, 0.6 * pulse);   g.fillCircle(b.x, b.y - 8, 7);
    g.fillStyle(0xff3300, 0.95);
    g.fillRect(b.x - 48, b.y + 12, 12, 22); g.fillRect(b.x + 36, b.y + 12, 12, 22);
    g.lineStyle(2, mc, pulse);
    g.strokeTriangle(b.x, b.y - 52, b.x - 52, b.y + 2, b.x + 52, b.y + 2);
    if (rage) {
      g.lineStyle(1.5, ac, pulse * 0.7); g.strokeCircle(b.x, b.y, 65 + pulse * 8);
    }
  }

  // ── Boss extras: mines (GUARDIAN), split bullet markers (NEXUS) ──
  _drawBossExtras(g, now) {
    const b = this.boss;
    if (!b) return;
    // GUARDIAN設置弾（脈動する警告円）
    if (b.mines) {
      for (const m of b.mines) {
        const p = 0.5 + 0.5 * Math.sin(now * 0.012);
        g.fillStyle(0x66ccff, 0.15 * p); g.fillCircle(m.x, m.y, 22);
        g.lineStyle(2, 0x66ccff, 0.6 + p * 0.4); g.strokeCircle(m.x, m.y, 14 + p * 6);
        g.fillStyle(0x66ccff, 0.7); g.fillCircle(m.x, m.y, 4);
      }
    }
    // NEXUS分裂弾マーカー（カウントダウン風）
    if (b.splitBullets) {
      for (const sb of b.splitBullets) {
        const p = 0.5 + 0.5 * Math.sin(now * 0.015);
        g.fillStyle(0xffaa00, 0.2 * p); g.fillCircle(sb.x, sb.y, 16);
        g.lineStyle(1.5, 0xffaa00, 0.6 + p * 0.3); g.strokeCircle(sb.x, sb.y, 10);
        g.fillStyle(0xffaa00, 0.8); g.fillCircle(sb.x, sb.y, 3);
      }
    }
  }

  _drawEnemyBullets(g) {
    for (const b of this.eBullets) {
      g.fillStyle(b.col, 0.22); g.fillCircle(b.x, b.y, 9);
      g.fillStyle(b.col, 0.9);  g.fillCircle(b.x, b.y, 4.5);
      g.fillStyle(0xffffff, 0.75); g.fillCircle(b.x, b.y, 2);
    }
  }

  _drawPowerups(g, now) {
    for (const p of this.powerups) {
      const pl = 0.5 + 0.5 * Math.sin(now * 0.009 + p.x);
      g.fillStyle(p.col, 0.13 * pl); g.fillCircle(p.x, p.y, 20);
      g.lineStyle(2, p.col, pl);     g.strokeCircle(p.x, p.y, 13);
      g.fillStyle(p.col, 0.7);       g.fillCircle(p.x, p.y, 9);
    }
  }
}

// ================================================================
//  GAME OVER SCENE
// ================================================================
class GameOverScene extends Phaser.Scene {
  constructor() { super('GameOver'); }
  init(d) { this.finalScore = d.score || 0; this.finalWave = d.wave || 1; }

  create() {
    const g = this.add.graphics();
    g.fillStyle(C.BG, 1); g.fillRect(0, 0, W, H);
    g.lineStyle(1, 0xffffff, 0.025);
    for (let y = 0; y < H; y += 4) g.lineBetween(0, y, W, y);
    this.cameras.main.fadeIn(600, 0, 0, 0);

    const ts = (sz, col = '#ff2244') => ({ fontFamily: 'Orbitron, monospace', fontSize: sz, color: col });
    const go = this.add.text(W / 2, H * 0.27, 'GAME OVER', ts('48px'))
      .setOrigin(0.5).setStroke('#ff0000', 3)
      .setShadow(0, 0, '#ff0000', 20, true);
    this.tweens.add({ targets: go, alpha: { from: 0.6, to: 1 }, duration: 750, yoyo: true, repeat: -1 });

    this.add.text(W / 2, H * 0.44, 'SCORE',                           ts('13px', '#446688')).setOrigin(0.5);
    this.add.text(W / 2, H * 0.50, this.finalScore.toLocaleString(),   ts('40px', '#00ffff')).setOrigin(0.5).setStroke('#003366', 3);
    this.add.text(W / 2, H * 0.61, `WAVE REACHED :  ${this.finalWave}`, ts('14px', '#ff00ff')).setOrigin(0.5);

    // ARIA / ECHO lines
    const echo = this.add.text(W / 2, H * 0.70, 'ECHO: 緊急復元プロトコル起動...', ts('11px', '#00ff88')).setOrigin(0.5);
    this.tweens.add({ targets: echo, alpha: 0, duration: 900, yoyo: true, repeat: -1 });

    const retryTxt = IS_MOBILE ? '[ TAP  —  RETRY ]' : '[ SPACE  /  CLICK  —  RETRY ]';
    const r = this.add.text(W / 2, H * 0.79, retryTxt, ts('15px', '#00ff99')).setOrigin(0.5);
    this.tweens.add({ targets: r, alpha: 0, duration: 550, yoyo: true, repeat: -1 });
    this.add.text(W / 2, H * 0.87, '[ T — TITLE ]', ts('12px', '#334455')).setOrigin(0.5);

    this.input.keyboard.on('keydown-SPACE', () => this._go('Game'));
    this.input.keyboard.on('keydown-T',     () => this._go('Title'));
    this.input.on('pointerdown',            () => this._go('Game'));
  }

  _go(scene) {
    this.cameras.main.fadeOut(400, 0, 0, 0);
    this.time.delayedCall(400, () => this.scene.start(scene));
  }
}

// ================================================================
//  ENDING SCENE
// ================================================================
class EndingScene extends Phaser.Scene {
  constructor() { super('Ending'); }
  init(d) { this.finalScore = d?.score || 0; }

  create() {
    this.phase = 'title'; // 'title' → 'epilogue' → 'credits'

    // Background
    this.stars = Array.from({ length: 180 }, () => ({
      x: Math.random() * W, y: Math.random() * H,
      spd: Math.random() * 0.6 + 0.15, r: Math.random() * 1.4 + 0.3,
      ph: Math.random() * Math.PI * 2,
    }));
    this.gBg = this.add.graphics();

    this.cameras.main.fadeIn(1200, 0, 0, 0);

    // Mission complete header
    this.txtMission = this.add.text(W / 2, H * 0.22, 'MISSION COMPLETE', {
      fontFamily: 'Orbitron, monospace', fontSize: '30px', color: '#00ffff',
      stroke: '#003366', strokeThickness: 3,
      shadow: { offsetX: 0, offsetY: 0, color: '#00ffff', blur: 25, fill: true },
    }).setOrigin(0.5).setAlpha(0).setDepth(10);

    this.txtNexus = this.add.text(W / 2, H * 0.32, 'NEXUS CORE — DESTROYED', {
      fontFamily: 'Orbitron, monospace', fontSize: '14px', color: '#ff2244', letterSpacing: 2,
    }).setOrigin(0.5).setAlpha(0).setDepth(10);

    this.txtScore = this.add.text(W / 2, H * 0.40, `FINAL SCORE  ${this.finalScore.toLocaleString()}`, {
      fontFamily: 'Orbitron, monospace', fontSize: '16px', color: '#ffee00',
    }).setOrigin(0.5).setAlpha(0).setDepth(10);

    const contTxt = IS_MOBILE ? '▶  TAP — CONTINUE  ◀' : '▶  PRESS SPACE — CONTINUE  ◀';
    this.txtPrompt = this.add.text(W / 2, H * 0.55, contTxt, {
      fontFamily: 'Orbitron, monospace', fontSize: '13px', color: '#00ff99',
    }).setOrigin(0.5).setAlpha(0).setDepth(10);

    this.tweens.add({ targets: this.txtMission, alpha: 1, duration: 1500, delay: 600 });
    this.tweens.add({ targets: this.txtNexus,   alpha: 1, duration: 1200, delay: 1400 });
    this.tweens.add({ targets: this.txtScore,   alpha: 1, duration: 1000, delay: 2000 });
    this.tweens.add({ targets: this.txtPrompt,  alpha: { from: 0.2, to: 1 }, duration: 700, yoyo: true, repeat: -1, delay: 2800 });

    // Dialog (for epilogue)
    this.dialog = new DialogUI(this);

    // Credits container (hidden until needed)
    this.creditsText = null;
    this.creditsTween = null;

    // Input
    this.keys = this.input.keyboard.addKeys('SPACE,T');
    this.input.keyboard.on('keydown-SPACE', this._onSpace, this);
    this.input.keyboard.on('keydown-T',     () => this._gotoTitle());
    this.input.on('pointerdown', this._onSpace, this);

    this.t = 0;
  }

  _onSpace() {
    if (this.phase === 'title') {
      this._startEpilogue();
    } else if (this.phase === 'epilogue') {
      this.dialog.advance();
    } else if (this.phase === 'credits') {
      if (this.creditsText && this.creditsText.y < 0) {
        // Skip credits to end
        this.creditsTween?.stop();
        this.creditsText.y = -this.creditsText.height;
        this._showTitlePrompt();
      } else {
        this._gotoTitle();
      }
    }
  }

  _startEpilogue() {
    this.phase = 'epilogue';
    this.txtMission.setAlpha(0);
    this.txtNexus.setAlpha(0);
    this.txtScore.setAlpha(0);
    this.txtPrompt.setAlpha(0);

    this.dialog.start(STORY_DATA.ending.epilogue, () => {
      this._startCredits();
    });
  }

  _startCredits() {
    this.phase = 'credits';
    this.dialog._hide && this.dialog._hide();

    const lines = STORY_DATA.ending.credits;
    const fullText = lines.join('\n');
    const startY = H + 60;

    this.creditsText = this.add.text(W / 2, startY, fullText, {
      fontFamily: 'Orbitron, monospace', fontSize: '14px', color: '#aabbcc',
      align: 'center', lineSpacing: 14,
    }).setOrigin(0.5, 0).setDepth(10);

    // Highlight special lines
    // (Phaser text doesn't support per-line color easily, so we just style the whole block)

    const duration = Math.max(lines.length * 1800, 20000);
    this.creditsTween = this.tweens.add({
      targets: this.creditsText,
      y: -this.creditsText.height - 80,
      duration,
      ease: 'Linear',
      onComplete: () => this._showTitlePrompt(),
    });
  }

  _showTitlePrompt() {
    const t = this.add.text(W / 2, H * 0.82, '[ SPACE / T — TITLE ]', {
      fontFamily: 'Orbitron, monospace', fontSize: '13px', color: '#00ff99',
    }).setOrigin(0.5).setDepth(15);
    this.tweens.add({ targets: t, alpha: 0, duration: 600, yoyo: true, repeat: -1 });
    this.phase = 'done';
  }

  _gotoTitle() {
    this.cameras.main.fadeOut(700, 0, 0, 0);
    this.time.delayedCall(700, () => this.scene.start('Title'));
  }

  update(time, dt) {
    this.t += dt;
    const now = Date.now();
    const g = this.gBg; g.clear();
    g.fillStyle(C.BG, 1); g.fillRect(0, 0, W, H);
    // Slow nebula
    g.fillStyle(0x040028, 0.6); g.fillCircle(W * 0.35 + Math.sin(this.t * 0.0002) * 20, H * 0.45, 200);
    g.fillStyle(0x001412, 0.4); g.fillCircle(W * 0.65, H * 0.6, 160);
    for (const s of this.stars) {
      s.y += s.spd * (dt / 16) * 0.3;
      if (s.y > H) { s.y = -4; s.x = Math.random() * W; }
      g.fillStyle(0xaabbdd, 0.35 + 0.35 * Math.sin(now * 0.001 + s.ph));
      g.fillCircle(s.x, s.y, s.r);
    }
    this.dialog.update(dt);
  }
}

// ================================================================
//  PHASER CONFIG
// ================================================================
new Phaser.Game({
  type: Phaser.AUTO,
  parent: 'game-container',
  width: W, height: H,
  backgroundColor: '#00010f',
  scene: [TitleScene, GameScene, GameOverScene, EndingScene],
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: IS_MOBILE ? Phaser.Scale.CENTER_HORIZONTALLY : Phaser.Scale.CENTER_BOTH,
  },
  render: { antialias: true, pixelArt: false },
});
</script>
</body>
</html>
